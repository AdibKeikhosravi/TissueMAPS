#! /usr/bin/env python
# encoding: utf-8
import os
import sys
import copy
import random
from gi.repository import Vips
from scipy.misc import imread
import numpy as np
import util
import pyramidize
import illumcorrect
import stitch
import segment
import imageutil
from image_toolbox import config
from image_toolbox.util import load_config, check_config

"""
Illuminati is a command line tool for pre-processing images for TissueMAPS.
It combines the following routines:
* shifting (-s)
* illumination correcting (-i)
* thresholding (-t)
Each of these routines comes with a separate command line interface that provides
additional functionality and can be used independently. For more details on the
individual steps see the respective files.

A potential call (from BASH) to this tool could look something like this:

    $ illuminati \\
        -sit TIFF/15*_r0[1-4]*_c0[1-4]*DAPI*.png -o out.png \\

See all available options with:

    $ illuminati --help

Some example use cases:

    - Create a pyramid out of segmentation files, retaining their 16 bit depth:

        $ illuminati --area-mask --png --make-global-ids path/to/*.png -o my_cell_id_pyramid

    - Create a pyramid of cell outlines, also retaining their 16 bit depth:

        $ illuminati --outline-mask --png path/to/*.png -o my_outline_pyramid

    - Create a serialized numpy array that holds all cell centroids (border cells removed):

        $ illuminati --cell-centroids path/to/label_matrices/*.png -o my_array.npy

    - Create id tables:

        $ illuminati --id-luts path/to/label_matrices/*.png -o id_tables

    - Create a numpy array that holds information about sites:

        $ illuminati --gather-siteinfo path/to/label_matrices/*.png -o siteinfo.npy

"""

__version__ = '0.1.0'


logo = u'''
   .
   I        Illuminati (%(version)s)
  LLU       Creates pyramid images for tissueMAPS.
 MINATI
'''


# TODO: define functions that can be called via the command line interface and
# and the user interface (server)

def load_images(config_settings, files):
    # Prepare file grid
    file_grid = stitch.build_file_grid(config_settings, files)
    vips_image_grid = copy.deepcopy(file_grid)

    max_id_upto_now = 0
    for i in range(len(file_grid)):
        for j in range(len(file_grid[0])):
            im = Vips.Image.new_from_file(file_grid[i][j])

            # Should the ids be computed as RGB triples?
            # If yes, don't remove border cells and just create the RGB images!
            if args.make_global_ids:
                # Should the result be a RGB area mask or RGB outline mask
                if args.area_mask:
                    im, max_id_upto_now = segment.local_to_global_ids_vips(im, max_id_upto_now)
                    max_id_upto_now += 1
                if args.outline_mask:
                    ids, max_id_upto_now = segment.local_to_global_ids_vips(im, max_id_upto_now)
                    max_id_upto_now += 1
                    outline = segment.outlines_vips(im)
                    im = outline.ifthenelse(ids, 0) # Make everything except the outline black
            else:
                if args.area_mask:
                    im = segment.remove_border_cells_vips(im)
                if args.outline_mask:
                    im = segment.remove_border_cells_vips(im)
                    im = segment.outlines_vips(im)

            vips_image_grid[i][j] = im

    return vips_image_grid


def apply_illumination_correction(config_settings, vips_image_grid, files):
    illcorr = illumcorrect.Illumcorrect(config_settings, shift=args.shift)
    stats_file = illcorr.get_stats_file_name(files)
    mean, std = illumcorrect.load_statistics_from_mat_file_vips(stats_file)
    for i in range(len(vips_image_grid)):
        for j in range(len(vips_image_grid[0])):
            img = vips_image_grid[i][j]
            vips_image_grid[i][j] = \
                illumcorrect.illum_correction_vips(img, mean, std)

    return vips_image_grid


def apply_shift(config_settings, stitched_img, files):
    project = util.Project(config_settings)
    project_dir = project.get_rootdir_from_image_file(files[0])
    cycles = util.Cycles(config_settings)
    cycles.specify(project_dir)
    cycle_nr = cycles.get_cycle_nr_from_filename(files[0])
    cycle_nrs = sorted([c.cycle_number for c in cycles.directories])
    shift_desc_idx = cycle_nrs.index(cycle_nr)
    stitched_img = stitch.global_shift(stitched_img, shift_desc_idx,
                                       cycles.descriptors)

    return stitched_img


def apply_threshold(stitched_img, files,
                    thresh_value=None, thresh_sample_size=None,
                    thresh_percentage=None):
    # TODO: make some checks for thresh type
    if thresh_value:
        val = args.thresh_value
    else:
        sample_size = thresh_sample_size
        # Adjust sample size if set too large
        if thresh_sample_size > len(files):
            sample_size = len(files)
        # The files from which to sample threshold
        sample_files = random.sample(files, sample_size)
        sample_images = map(Vips.Image.new_from_file, sample_files)
        val = imageutil.get_threshold(sample_images, thresh_percentage)
    lut = imageutil.create_thresholding_LUT(val)
    # Map image through lookup table
    stitched_img = stitched_img.maplut(lut)

    return stitched_img


if __name__ == '__main__':
    import argparse

    print logo % {'version': __version__}

    parser = argparse.ArgumentParser(
        description='Create pyramid images for TissueMAPS.')

    parser.add_argument('files', nargs='*',
                        help='image files to process (pattern),\
                        e.g. TIFF/*.png')

    parser.add_argument('-o', '--output', dest='output_dir', required=True,
                        help="directory where the pyramid should be saved")

    parser.add_argument('-c', '--config', dest='config',
                        help='path to custom yaml configuration file \
                        (defaults to "image_toolbox" configuration)')

    parser.add_argument('-s', '--shift', dest='shift',
                        action='store_true', default=False,
                        help="shift stitched image according to descriptor file")
    parser.add_argument('-i', '--illum_correct', dest='illum_correct',
                        action='store_true', default=False,
                        help="correct images for illumination\
                        according to stats file")
    parser.add_argument('-t', '--thresh', dest='thresh',
                        action='store_true', default=False,
                        help="threshold (rescale) stitched image")

    parser.add_argument('--no-rescale', dest='no_rescale',
                        action='store_true', default=False,
                        help="don't perform any 16bit -> 8bit rescaling."
                             "The resulting pyramid will have 16bit PNG tiles.")

    parser.add_argument('--make-global-ids', dest='make_global_ids',
                        action='store_true', default=False,
                        help="if all the cell labels should be made into "
                             "globally unique labels.")

    parser.add_argument('--cell-centroids', dest='cell_centroids',
                        action='store_true', default=False,
                        help="if the centroid for each cell should be computed and be saved"
                             " as a numpy array.")
    parser.add_argument('--id-luts', dest='id_luts',
                        action='store_true', default=False,
                        help="if lookup tables for the cell ids should be created. "
                             " These tables are just int32 numpy arrays with the same name"
                             " as the original segmentation images.")
    parser.add_argument('--gather-siteinfo', dest='gather_siteinfo',
                        action='store_true', default=False,
                        help="""
if a siteinfo matrix should be created that holds information "
about sites. The matrix has dimension (n x 4) where n is the number"
of sites and the columns corresond to: absolute site number (sXXXX),"
row number (rXX), column number (cXX), integer offset thas has to"
be added to the local ids in that site in order to make those ids global."
This offset is computed in the fashion: for i in rows { for j in cols }"
These tables are just int32 numpy arrays with the same name"
as the original segmentation images.""")


    parser.add_argument('--area-mask', dest='area_mask',
                        action='store_true', default=False,
                        help="if the masks should consist of the whole cell areas")
    parser.add_argument('--outline-mask', dest='outline_mask',
                        action='store_true', default=False,
                        help="if the masks should consist of the cell outlines")
    parser.add_argument('--png', dest='png',
                        action='store_true', default=False,
                        help="Save the pyramid tiles as png, default is jpg.")

    parser.add_argument('--thresh-value', dest='thresh_value',
                        type=float, default=False,
                        help="pixel value for threshold")
    parser.add_argument('--thresh-percent', dest='thresh_percentage',
                        type=float, default=0.01,
                        help="percentage of pixel values above threshold")
    parser.add_argument('--thresh-sample', dest='thresh_sample_size',
                        type=int, default=10,
                        help="number of files to use for threshold estimation")

    args = parser.parse_args()

    if not args.files or not all(map(util.is_image, args.files)):
        parser.print_help()
        sys.exit(1)

    if not args.output_dir:
        print 'You need to specify an output directory'
        sys.exit(1)

    if not os.path.exists(args.output_dir) \
            and not (args.cell_centroids or args.id_luts or args.gather_siteinfo):
        print '.. Creating pyramid output directory'
        os.makedirs(args.output_dir)

    if args.thresh_value and not args.thresh:
        print '\'--thresh-value\' command only works together with \'-t\' command'

    print '.. Creating layer "%s"' % os.path.basename(args.output_dir)

    files = args.files

    if args.config:
        # Overwrite default "image_toolbox" configuration
        config_settings = load_config(args.config)
        check_config(config_settings)

    #######################################################################
    #                           LOADING IMAGES                            #
    #######################################################################

    if args.id_luts:
        max_id_upto_now = 0
        print('ᐄ  CREATING ID LOOKUP TABLES ')
        for i in range(len(file_grid)):
            print '   row: %d' % i
            for j in range(len(file_grid[0])):
                print '    col: %d' % j
                site_fname = file_grid[i][j]
                mat = imread(site_fname)
                mat = segment.remove_border_cells(mat)
                mat, max_id_upto_now = segment.create_id_lookup_matrices(
                    mat, max_id_upto_now)

                fname = 'ROW{rownr:0>5}_COL{colnr:0>5}.npy'.format(
                    rownr=(i+1), colnr=(j+1))
                fname_abs = os.path.join(args.output_dir, fname)
                print '    Saving file: ' + fname_abs
                with open(fname_abs, 'w') as f:
                    np.save(f, mat)
        sys.exit(0)

    if args.gather_siteinfo:
        mat = segment.gather_siteinfo(file_grid)
        out = os.path.splitext(args.output_dir)[0] + '.npy'
        print 'Saving: ' + out
        with open(out, 'w') as f:
            np.save(f, mat)
        sys.exit(0)


    if args.cell_centroids:
        print('ᐄ  COMPUTING CELL CENTROIDS')
        max_id_upto_now = 0
        centroids = []
        for i in range(len(file_grid)):
            print '   row: %d' % i
            for j in range(len(file_grid[0])):
                print '   col: %d' % j
                print '   ' + file_grid[i][j]
                mat = imread(file_grid[i][j])
                mat = segment.remove_border_cells(mat)
                site_centroids, max_id_upto_now = \
                    segment.compute_cell_centroids(mat, i, j, max_id_upto_now)
                centroids.append(site_centroids)

        centroids = np.vstack(centroids)
        fname = os.path.splitext(args.output_dir)[0] + '.npy'
        with open(fname, 'w') as f:
            np.save(f, centroids)
        sys.exit(0)

    # Create a vips image for each file
    print '.. Loading images'
    if args.outline_mask:
        print('ᐄ  CREATING OUTLINE MASKS')
    elif args.area_mask:
        print('ᐄ  CREATING AREA MASKS')
    else:
        pass

    vips_image_grid = load_images(config_settings, files)

    #######################################################################
    #                       ILLUMINATION CORRECTING                       #
    #######################################################################

    if args.illum_correct:
        print 'ᐄ  CORRECTING IMAGES FOR ILLUMINATION'

        vips_image_grid = apply_illumination_correction(config_settings,
                                                        vips_image_grid,
                                                        files)

    print 'ᐄ  STITCHING IMAGES' + (' & SHIFTING' if args.shift else '')

    #######################################################################
    #                             STITCHING                               #
    #######################################################################

    stitched_img = stitch.stitch_all_images(vips_image_grid)

    #######################################################################
    #                              SHIFTING                               #
    #######################################################################

    if args.shift:
        stitched_img = apply_shift(config_settings, stitched_img, files)

    #######################################################################
    #                            THRESHOLDING                             #
    #######################################################################

    # If 'thresh' has been set then a certain percentage of the pixels
    # with the largest value will be thresholded (i.e., set to the lowest of their values).
    # A sample of size `args.thresh_sample_size` is used to determine the cut off value
    # above which the `args.thresh_percentage`% of all pixels with the largest values lie.
    if args.thresh:
        print 'ᐄ  THRESHOLDING'
        if args.thresh_value:
            print '   ... Using provided threshold value'
        else:
            print '   ... Computing threshold value'

        stitched_img = apply_threshold(stitched_img, files,
                                       thresh_value=args.thresh_value,
                                       thresh_sample_size=args.thresh_sample_size,
                                       thresh_percentage=args.thresh_percentage)

    # The image will be rescaled s.t. the pixel values fill the whole range
    # of possible values (0 to 2^16) and then converted to 8 bit
    if not args.make_global_ids and not args.no_rescale:
        stitched_img = stitched_img.scale()

    #######################################################################
    #                            PYRAMIDIZING                             #
    #######################################################################

    print 'ᐄ  CREATING ZOOMIFY PYRAMID FROM STITCHED IMAGE'
    if not args.no_rescale and not args.png:
        pyramidize.create_pyramid(stitched_img, args.output_dir)
    else:
        # The stitched image wasn't rescaled and is still 16 bit.
        # In order to have the resulting pyramid be 16 bit as well, we have
        # do change the file format from JPEG to PNG.
        # Note that pyramids created in this manner shouldn't be visualized directly
        # in the browser since they will be coerced to 8 bit, thus losing information.
        pyramidize.create_pyramid(stitched_img, args.output_dir,
                                  tile_file_extension='.png')

    print '🍺  Done!'
