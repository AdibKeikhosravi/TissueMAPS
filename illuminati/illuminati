#! /usr/bin/env python
# encoding: utf-8
import os
import sys
import copy
import random
from gi.repository import Vips
from scipy.misc import imread

import util
import pyramidize
import illumcorrect
import stitch
import segment
import imageutil

"""
Illuminati is a command line tool for pre-processing images for TissueMAPS.
It combines the following routines:
* shifting (-s)
* illumination correcting (-i)
* thresholding (-t)
Each of these routines comes with a separate command line interface that provides
additional functionality and can be used independently. For more details on the
individual steps see the respective files.

A potential call (from BASH) to this tool could look something like this:

    $ illuminati \\
        -sit TIFF/15*_r0[1-4]*_c0[1-4]*DAPI*.png -o out.png \\

See all available options with:

    $ illuminati --help

Some example use cases:

    - Create a pyramid out of segmentation files, retaining their 16 bit depth:

        $ illuminati --area-mask --png --make-global-ids path/to/*.png -o my_cell_id_pyramid

    - Create a pyramid of cell outlines, also retaining their 16 bit depth:

        $ illuminati --outline-mask --png path/to/*.png -o my_outline_pyramid

"""

__version__ = '0.1.0'


logo = u'''
   .
   I        Illuminati (%(version)s)
  LLU       Creates pyramid images for tissueMAPS.
 MINATI
'''


if __name__ == '__main__':
    import argparse

    print logo % {'version': __version__}

    parser = argparse.ArgumentParser(
        description='Create pyramid images for TissueMAPS.')

    parser.add_argument('files', nargs='*',
                        help='image files to process (pattern),\
                        e.g. TIFF/*.png')

    parser.add_argument('-o', '--output', dest='output_dir', required=True,
                        help="directory where the pyramid should be saved")

    parser.add_argument('-c', '--config', dest='config',
                        default=os.path.join(os.path.dirname(__file__), '..',
                                             'config.yaml'),
                        help='use custom yaml configuration file')

    parser.add_argument('-s', '--shift', dest='shift',
                        action='store_true', default=False,
                        help="shift stitched image according to descriptor file")
    parser.add_argument('-i', '--illum_correct', dest='illum_correct',
                        action='store_true', default=False,
                        help="correct images for illumination\
                        according to stats file")
    parser.add_argument('-t', '--thresh', dest='thresh',
                        action='store_true', default=False,
                        help="threshold (rescale) stitched image")

    parser.add_argument('--no-rescale', dest='no_rescale',
                        action='store_true', default=False,
                        help="don't perform any 16bit -> 8bit rescaling."
                             "The resulting pyramid will have 16bit PNG tiles.")

    parser.add_argument('--make-global-ids', dest='make_global_ids',
                        action='store_true', default=False,
                        help="if all the cell labels should be made into "
                             "globally unique labels.")
    parser.add_argument('--area-mask', dest='area_mask',
                        action='store_true', default=False,
                        help="if the masks should consist of the whole cell areas")
    parser.add_argument('--outline-mask', dest='outline_mask',
                        action='store_true', default=False,
                        help="if the masks should consist of the cell outlines")
    parser.add_argument('--png', dest='png',
                        action='store_true', default=False,
                        help="Save the pyramid tiles as png, default is jpg.")

    parser.add_argument('--thresh-value', dest='thresh_value',
                        type=float, default=False,
                        help="pixel value for threshold")
    parser.add_argument('--thresh-percent', dest='thresh_percentage',
                        type=float, default=0.01,
                        help="percentage of pixel values above threshold")
    parser.add_argument('--thresh-sample', dest='tresh_sample_size',
                        type=int, default=10,
                        help="number of files to use for threshold estimation")

    args = parser.parse_args()

    if not args.files or not all(map(util.is_image, args.files)):
        parser.print_help()
        sys.exit(1)

    if not args.output_dir:
        print 'You need to specify an output directory'
        sys.exit(1)

    if not os.path.exists(args.output_dir):
        print '.. Creating pyramid output directory'
        os.makedirs(args.output_dir)

    if args.thresh_value and not args.thresh:
        print '\'--thresh-value\' command only works together with \'-t\' command'

    print '.. Creating layer "%s"' % os.path.basename(args.output_dir)

    files = args.files

    # Get configuration settings
    config_settings = util.load_config(args.config)
    util.check_config(config_settings)

    # Get project specifications
    project = util.Project(config_settings)

    # Prepare file grid for stitching
    file_grid = stitch.build_file_grid(config_settings, files)
    vips_image_grid = copy.deepcopy(file_grid)

    # Create a vips image for each file
    print '.. Loading images'
    if args.outline_mask:
        print('ᐄ  CREATING OUTLINE MASKS')
    elif args.area_mask:
        print('ᐄ  CREATING AREA MASKS')
    else:
        pass

    max_id_upto_now = 0
    for i in range(len(file_grid)):
        for j in range(len(file_grid[0])):
            im = Vips.Image.new_from_file(file_grid[i][j])

            # If masks should be created we have to do some further processing
            if args.area_mask or args.outline_mask:
                im = segment.remove_border_cells_vips(im)
            if args.area_mask and args.make_global_ids:
                im, max_id_upto_now = segment.local_to_global_ids_vips(im, max_id_upto_now)
                max_id_upto_now += 1
            if args.outline_mask:
                im = segment.outlines_vips(im)

            vips_image_grid[i][j] = im

    #######################################################################
    #                       ILLUMINATION CORRECTING                       #
    #######################################################################

    if args.illum_correct:
        print 'ᐄ  CORRECTING IMAGES FOR ILLUMINATION'
        illumcorr_obj = illumcorrect.Illumcorrect(config_settings,
                                                  shift=args.shift)
        stats_file = illumcorr_obj.get_stats_file_name(files)
        mean, std = illumcorrect.load_statistics_from_mat_file_vips(stats_file)
        for i in range(len(vips_image_grid)):
            for j in range(len(vips_image_grid[0])):
                img = vips_image_grid[i][j]
                vips_image_grid[i][j] = \
                    illumcorrect.illum_correction_vips(img, mean, std)

    print 'ᐄ  STITCHING IMAGES' + (' & SHIFTING' if args.shift else '')

    #######################################################################
    #                             STITCHING                               #
    #######################################################################

    stitched_img = stitch.stitch_all_images(vips_image_grid)

    #######################################################################
    #                              SHIFTING                               #
    #######################################################################

    if args.shift:
        project_dir = project.get_rootdir_from_image_file(files[0])
        cycles = util.Cycles(config_settings)
        cycles.specify(project_dir)
        cycle_nr = cycles.get_cycle_nr_from_filename(files[0])
        cycle_nrs = sorted([c.cycle_number for c in cycles.directories])
        shift_desc_idx = cycle_nrs.index(cycle_nr)
        stitched_img = stitch.global_shift(stitched_img, shift_desc_idx,
                                           cycles.descriptors)

    #######################################################################
    #                            THRESHOLDING                             #
    #######################################################################

    # If 'thresh' has been set then a certain percentage of the pixels
    # with the largest value will be thresholded (i.e., set to the lowest of their values).
    # A sample of size `args.tresh_sample_size` is used to determine the cut off value
    # above which the `args.thresh_percentage`% of all pixels with the largest values lie.
    if args.thresh:
        print 'ᐄ  THRESHOLDING'
        if args.thresh_value:
            val = args.thresh_value
            print '   ... Using provided threshold value'
        else:
            sample_size = args.tresh_sample_size
            # Adjust sample size if set too large
            if args.tresh_sample_size > len(files):
                sample_size = len(files)
            # The files from which to sample threshold
            sample_files = random.sample(files, sample_size)
            sample_images = map(Vips.Image.new_from_file, sample_files)
            print '   ... Computing threshold value'
            val = imageutil.get_threshold(sample_images,
                                          args.thresh_percentage)
        lut = imageutil.create_thresholding_LUT(val)
        # Map image through lookup table
        print '   ... Applying threshold'
        stitched_img = stitched_img.maplut(lut)

    # The image will be rescaled s.t. the pixel values fill the whole range
    # of possible values (0 to 2^16) and then converted to 8 bit
    if not args.make_global_ids and not args.no_rescale:
        stitched_img = stitched_img.scale()

    #######################################################################
    #                            PYRAMIDIZING                             #
    #######################################################################

    print 'ᐄ  CREATING ZOOMIFY PYRAMID FROM STITCHED IMAGE'
    if not args.no_rescale and not args.png:
        pyramidize.create_pyramid(stitched_img, args.output_dir)
    else:
        # The stitched image wasn't rescaled and is still 16 bit.
        # In order to have the resulting pyramid be 16 bit as well, we have
        # do change the file format from JPEG to PNG.
        # Note that pyramids created in this manner shouldn't be visualized directly
        # in the browser since they will be coerced to 8 bit, thus losing information.
        pyramidize.create_pyramid(stitched_img, args.output_dir,
                                  tile_file_extension='.png')

    print '🍺  Done!'
