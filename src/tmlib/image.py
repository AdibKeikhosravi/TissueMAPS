import os
import numpy as np
import scipy.ndimage as ndi
import skimage.measure
import skimage.color
from abc import ABCMeta
from abc import abstractmethod
import logging
from cached_property import cached_property
from . import image_utils
from .readers import DatasetReader
from .readers import ImageReader
from .writers import ImageWriter
from .errors import MetadataError
from .metadata import IllumstatsImageMetadata

logger = logging.getLogger(__name__)

#: Image files are generated by :py:mod:`tmlib.imextract`.
SUPPORTED_IMAGE_FILE_EXTENSIONS = {
    '.png', '.tif', '.tiff', '.ppm', '.jpg', '.jpeg'
}


def is_image_file(filename):
    '''
    Check if filename ends with a supported file extension.

    Parameters
    ----------
    filename: str
        name of the image file

    Returns
    -------
    bool
        ``True`` if `filename` represents an image and ``False`` otherwise

    See also
    --------
    :py:const:`tmlib.image.SUPPORTED_IMAGE_FILE_EXTENSIONS`
    '''
    return os.path.splitext(filename)[1] in SUPPORTED_IMAGE_FILE_EXTENSIONS


class Image(object):

    '''
    Abstract base class for an image, which represents a 2D pixels array.

    2D means that there is only one *z* resolution.
    However, the pixels array may still have more than 2 dimensions.
    The 3rd dimension represents color and is referred to as "bands".

    The class provides the pixel array as well as associated metadata.
    It makes use of lazy loading so that image objects can be created and their
    metadata attribute accessed without the pixels arrays being immediately
    loaded into memory.
    '''

    __metaclass__ = ABCMeta

    def __init__(self, pixels=None, metadata=None):
        '''
        Parameters
        ----------
        pixels: numpy.ndarray, optional
            pixels array (default: ``None``)
        metadata: tmlib.metadata.ImageMetadata, optional
            image metadata (default: ``None``)
        '''
        if pixels is not None:
            if not isinstance(pixels, np.ndarray):
                raise TypeError('Argument "pixels" must have type numpy.ndarray')
        self._pixels = pixels
        self.metadata = metadata

    @property
    def _filename(self):
        return self.__filename

    @_filename.setter
    def _filename(self, value):
        self.__filename = value

    @property
    def pixels(self):
        '''
        Returns
        -------
        numpy.ndarray
            pixels array
        '''
        if self._pixels is None:
            with ImageReader() as reader:
                self._pixels = reader.read(self._filename)
        return self._pixels

    @abstractmethod
    def create_from_file(filename, metadata):
        '''
        Create an image from file with lazy loading functionality, such that
        the pixel array is only loaded when the `pixels` property is accessed.

        Parameters
        ----------
        filename: str
            absolute path to file
        metadata: tmlib.metadata.ImageMetadata, optional
            image metadata (default: ``None``)

        Returns
        -------
        tmlib.image.Image
            an object of an implementation of the abstract base class
        '''

    @property
    def dimensions(self):
        '''
        Returns
        -------
        Tuple[int]
            y, x dimensions of the pixel array
        '''
        return self.pixels.shape[0:2]

    @property
    def bands(self):
        '''
        Bands represent colors. An RGB image has 3 bands while a greyscale
        image has only one band.

        Returns
        -------
        int
            number of bands in the pixel array
        '''
        if len(self.pixels.shape) > 2:
            self._bands = self.pixels.shape[2]
        else:
            self._bands = 1
        return self._bands

    @property
    def dtype(self):
        '''
        Returns
        -------
        str
            data type of the pixel array elements
        '''
        return self.pixels.dtype

    @property
    def is_float(self):
        '''
        Returns
        -------
        bool
            whether pixel array has float data type (numpy.float)
        '''
        return self.dtype == np.float

    @property
    def is_uint(self):
        '''
        Returns
        -------
        bool
            whether pixel array has unsigned integer data type
            (numpy.uint8 or numpy.uint16)
        '''
        return self.dtype == np.uint16 or self.dtype == np.uint8

    @property
    def is_binary(self):
        '''
        Returns
        -------
        bool
            whether pixel array has boolean data type (numpy.bool)
        '''
        return self.dtype == np.bool

    def write_to_file(self, filename):
        '''
        Write pixels array to file on disk.

        The format depends on the file extension:
            - *.png for PNG (8-bit and 16-bit)
            - *.tiff or *.tif for TIFF (8-bit and 16-bit)
            - *.jpeg or *.jpg for JPEG (8-bit)
            - *.ppm for PPM (8-bit and 16-bit)

        Parameters
        ----------
        filename: str
            absolute path to output file

        See also
        --------
        :py:class:`tmlib.writers.ImageWriter`
        '''
        with ImageWriter() as writer:
            writer.write(filename, self.pixels)

    def extract(self, y_offset, x_offset, height, width):
        '''
        Extract a continuous, rectangular area of pixels from the array.

        Parameters
        ----------
        y_offset: int
            index of the top, left point of the rectangle on the *y* axis
        x_offset: int
            index of the top, left point of the rectangle on the *x* axis
        height: int
            height of the rectangle, i.e. length of the rectangle along the
            *y* axis
        width: int
            width of the rectangle, i.e. length of the rectangle along the
            *x* axis

        Returns
        -------
        tmlib.image.Image
            extracted pixels with dimensions `height` x `width`
        '''
        pxls = self.pixels[y_offset:(y_offset+height), x_offset:(x_offset+width)]
        return self.__class__(pxls, self.metadata)

    def scale(self, threshold):
        '''
        Scale the pixel values to 8-bit such that `threshold` is 255.

        Parameters
        ----------
        threshold: int
            value above which pixel values will be set to 255, i.e.
            the range [0, `threshold`] will be mapped to range [0, 255]

        Returns
        -------
        tmlib.image.Image
            image with rescaled pixels
        '''
        if self.dtype == np.uint16:
            pxls = image_utils.map_to_uint8(self.pixels, 0, threshold)
            return self.__class__(pxls, self.metadata)
        elif self.dtype == np.uint8:
            return self
        else:
            TypeError(
                    'Only pixels with dtype "uint16" or "uint8" '
                    'can be scaled to 8-bit.')

    def join(self, image, direction):
        '''
        Join two pixels arrays.

        Parameters
        ----------
        image: tmlib.image.Image
            image object whose pixels should used for joining
        direction: str
            direction along which the two pixels arrays should be joined,
            either ``"horizontal"`` or ``"vertical"``

        Returns
        -------
        tmlib.image.Image
            image with joined pixels
        '''
        if direction == 'vertical':
            pxls = np.vstack([self.pixels, image.pixels])
        elif direction == 'horizontal':
            pxls = np.hstack([self.pixels, image.pixels])
        else:
            raise ValueError(
                        'Argument "direction" must be either '
                        '"horizontal" or "vertical"')
        return self.__class__(pxls, self.metadata)

    def merge(self, image, direction, offset):
        '''
        Merge pixels arrays of two images into one.

        Parameters
        ----------
        image: tmlib.image.Image
            image object whose pixels should used for merging
        direction: str
            direction along which the two pixels arrays should be merged,
            either ``"horizontal"`` or ``"vertical"``
        offset: int
            offset for `image` in the existing object

        Parameters
        ----------
        tmlib.image.Image
            image with rescaled pixels
        '''
        pxls = self.pixels.copy()
        if direction == 'vertical':
            pxls[offset:, :] = image.pixels[offset:, :]
        elif direction == 'horizontal':
            pxls[:, offset:] = image.pixels[:, offset:]
        else:
            raise ValueError(
                        'Argument "direction" must be either '
                        '"horizontal" or "vertical"')
        return self.__class__(pxls, self.metadata)

    def pad_with_background(self, n, side):
        '''
        Pad one side of the pixels array with zero value pixels.

        Parameters
        ----------
        n: int
            number of pixels that should be added along the given axis
        side: str
            side of the array that should be padded;
            either ``"top"``, ``"bottom"``, ``"left"``, or ``"right"``

        Returns
        -------
        tmlib.image.Image
            image with clipped pixels
        '''
        if side == 'top':
            pxls = np.zeros((n, self.dimensions[1]), dtype=self.dtype)
            pxls = np.vstack([pxls, self.pixels])
        elif side == 'bottom':
            pxls = np.zeros((n, self.dimensions[1]), dtype=self.dtype)
            pxls = np.vstack([self.pixels, pxls])
        elif side == 'left':
            pxls = np.zeros((self.dimensions[0], n), dtype=self.dtype)
            pxls = np.hstack([pxls, self.pixels])
        elif side == 'right':
            pxls = np.zeros((self.dimensions[0], n), dtype=self.dtype)
            pxls = np.hstack([self.pixels, pxls])
        else:
            raise ValueError(
                        'Argument "side" must be one of the following: '
                        '"top", "bottom", "left", "right"')
        return self.__class__(pxls, self.metadata)

    def shrink(self, factor):
        '''
        Reduce the size of the pixels.

        Parameters
        ----------
        factor: int
            factor by which the size of the pixels array should be reduced

        Returns
        -------
        tmlib.image.Image
            image with shrunken pixels
        '''
        pxls = skimage.measure.block_reduce(
                    self.pixels, (factor, factor),
                    func=np.mean).astype(self.dtype)
        return self.__class__(pxls, self.metadata)

    def align(self, crop=True):
        '''
        Align, i.e. shift and crop, an image based on calculated shift
        and overhang values.

        Parameters
        ----------
        crop: bool, optional
            whether images should cropped or rather padded
            with zero valued pixels (default: ``True``)

        Returns
        -------
        tmlib.image.Image
            aligned image

        Warning
        -------
        Alignment may change the dimensions of the image when `crop` is
        ``True``.
        '''
        if self.metadata is None:
            raise AttributeError(
                    'Image requires attribute "metadata" for alignment.')
        md = self.metadata
        pxls = image_utils.shift_and_crop(
                    self.pixels, y=md.y_shift, x=md.x_shift,
                    bottom=md.upper_overhang, top=md.lower_overhang,
                    right=md.left_overhang, left=md.right_overhang,
                    shift=not(md.is_omitted), crop=crop)
        new_object = self.__class__(pxls, self.metadata)
        new_object.metadata.is_aligned = True
        return new_object


class ChannelImage(Image):

    '''
    Class for a channel image: a 2D greyscale image with a single band.
    '''

    def __init__(self, pixels=None, metadata=None):
        '''
        Parameters
        ----------
        pixels: numpy.ndarray[uint8 or uint16], optional
            pixels array (default: ``None``)
        metadata: tmlib.metadata.ChannelImageMetadata, optional
            image metadata (default: ``None``)
        '''
        super(ChannelImage, self).__init__(pixels, metadata)
        if pixels is not None:
            if not self.is_uint:
                raise TypeError(
                        'Argument "pixels" must have 8-bit or 16-bit '
                        'unsigned integer type.')
            if self.bands != 1:
                raise ValueError(
                        'Argument "pixels" must be a two-dimensional array.')

    @staticmethod
    def create_from_file(filename, metadata=None):
        '''
        Create an image from file with lazy loading.

        Parameters
        ----------
        filename: str
            absolute path to the image file
        metadata: tmlib.metadata.ChannelImageMetadata, optional
            image metadata (default: ``None``)

        Returns
        -------
        tmlib.image.ChannelImage
            image with pixels read from file
        '''
        new_object = ChannelImage(metadata=metadata)
        new_object._filename = filename
        return new_object

    @staticmethod
    def create_as_background(y_dimension, x_dimension, dtype,
                             metadata=None, add_noise=False,
                             mu=None, sigma=None):
        '''
        Create an image with background pixels. By default background will be
        zero values. Optionally, Gaussian noise can be added to simulate
        camera background.

        Parameters
        ----------
        y_dimension: int
            length of the array along the y-axis
        x_dimension: int
            length of the array along the x-axis
        dtype: type
            data type of the array
        metadata: tmlib.metadata.ImageMetadata, optional
            image metadata (default: ``None``)
        add_noise: bool, optional
            add Gaussian noise (default: ``False``)
        noise_mu: int, optional
            mean of background noise (default: ``None``)
        noise_sigma: int, optional
            variance of background noise (default: ``None``)

        Returns
        -------
        tmlib.image.ChannelImage
            image with background pixels
        '''
        if add_noise:
            if mu is None or sigma is None:
                raise ValueError(
                        'Arguments "mu" and "sigma" are required '
                        'when argument "add_noise" is set to True.')
            pxls = np.random.normal(
                        mu, sigma, y_dimension * x_dimension).astype(dtype)
        else:
            pxls = np.zeros((y_dimension, x_dimension), dtype=dtype)
        return ChannelImage(pxls, metadata)

    def clip(self, threshold):
        '''
        Clip intensity values above `threshold`, i.e. set all pixel values
        above `threshold` to `threshold`.

        Parameters
        ----------
        threshold: int
            value above which pixel values should be clipped

        Returns
        -------
        tmlib.image.ChannelImage
            image with clipped pixels
        '''
        pxls = np.clip(self.pixels, 0, threshold)
        return ChannelImage(pxls, self.metadata)

    def smooth(self, sigma):
        '''
        Apply a Gaussian smoothing filter to the pixels array.

        Parameters
        ----------
        sigma: int
            size of the standard deviation of the Gaussian kernel

        Returns
        -------
        tmlib.image.ChannelImage
            image with smoothed pixels
        '''
        pxls = ndi.filters.gaussian_filter(self.pixels, sigma)
        return ChannelImage(pxls, self.metadata)

    def correct(self, stats):
        '''
        Correct image for illumination artifacts.

        Parameters
        ----------
        stats: tmlib.image.IllumstatsImages
            mean and standard deviation statistics at each pixel position
            calculated over all images of the same channel

        Returns
        -------
        tmlib.image.ChannelImage
            image with pixels corrected for illumination

        Raises
        ------
        ValueError
            when channel doesn't match between illumination statistics and
            image
        '''
        if self.metadata is None:
            raise AttributeError(
                    'Image requires attribute "metadata" '
                    'for correction of illumination artifacts.')
        if (stats.mean.metadata.channel != self.metadata.channel or
                stats.std.metadata.channel != self.metadata.channel):
            raise ValueError('Channel indices must match.')
        pxls = image_utils.correct_illumination(
                    self.pixels, stats.mean.pixels, stats.std.pixels)
        new_object = ChannelImage(pxls, self.metadata)
        new_object.metadata.is_corrected = True
        return new_object


class LabelImage(Image):

    '''
    Class for a labeled image: a 2D grayscale image with one band where pixels
    of each connected component (segmented object) have a unique integer value.
    '''

    def __init__(self, pixels=None, metadata=None):
        '''
        Parameters
        ----------
        pixels: numpy.ndarray[int32], optional
            pixels array (default: ``None``)
        metadata: tmlib.metadata.ImageMetadata, optional
            image metadata (default: ``None``)
        '''
        super(LabelImage, self).__init__(pixels, metadata)
        if pixels is not None:
            if self.dtype != 'int32':
                raise TypeError(
                        'Argument "pixels" must have data type int32.')
            if self.bands != 1:
                raise ValueError(
                        'Argument "pixels" must be a two-dimensional array.')

    @staticmethod
    def create_from_file(filename, metadata=None):
        '''
        Create an `ChannelImage` object from a file on disk.

        Parameters
        ----------
        filename: str
            absolute path to the image file
        metadata: tmlib.metadata.ImageMetadata, optional
            image metadata (default: ``None``)

        Returns
        -------
        tmlib.image.BrightfieldImage
            image with pixels read from file
        '''
        new_object = BrightfieldImage(metadata=metadata)
        new_object._filename = filename
        return new_object

    def get_outlines(self, keep_ids=False):
        '''
        Obtain the outlines of objects in the image.

        Parameters
        ----------
        keep_ids: bool, optional
            whether the ids (pixel values) of objects should be preserved;
            returns unsigned integer type if ``True`` and binary type otherwise
            (default: ``False``)

        Returns
        -------
        numpy.ndarray
            pixels array
        '''
        return image_utils.compute_outlines(self.pixels, keep_ids)

    @property
    def n_objects(self):
        '''
        Returns
        -------
        int
            number of objects (labeled connected components) in the image
        '''
        return len(np.unique(self.pixels[self.pixels > 0]))

    def remove_objects(self, ids):
        '''
        Remove certain objects from the image.

        Parameters
        ----------
        ids: List[int]
            ids of objects that should be removed

        Returns
        -------
        numpy.ndarray
            pixels array
        '''
        return image_utils.remove_objects(self.pixels, ids)


class BrightfieldImage(Image):

    '''
    Class for a brightfield image: a 2D RGB image with three bands
    and pixels with 8-bit unsigned integer type.
    '''

    def __init__(self, pixels=None, metadata=None):
        '''
        Parameters
        ----------
        pixels: numpy.ndarray[uint8]
            pixels array (default: ``None``)
        metadata: tmlib.metadata.ImageMetadata, optional
            image metadata (default: ``None``)
        '''
        super(BrightfieldImage, self).__init__(pixels, metadata)
        if pixels is not None:
            if self.dtype != np.uint8:
                raise TypeError(
                        'Argument "pixels" must have 8-bit unsigned integer '
                        'data type.')
            if self.bands != 3:
                raise ValueError(
                        'Argument "pixels" must be a three-dimensional array '
                        'with 3 bands.')

    @staticmethod
    def create_from_file(filename, metadata=None):
        '''
        Create an image from a file on disk.

        Parameters
        ----------
        filename: str
            absolute path to the image file
        metadata: tmlib.metadata.ImageMetadata, optional
            image metadata (default: ``None``)

        Returns
        -------
        tmlib.image.BrightfieldImage
            image with pixels read from file
        '''
        new_object = BrightfieldImage(metadata=metadata)
        new_object._filename = filename
        return new_object

    def split_bands(self, separation_mat=skimage.color.hed_from_rgb):
        '''
        Split different colors of a immunohistochemistry stain
        into separate channels based on
        Ruifrok and Johnston's color deconvolution method [1]_.

        Parameters
        ----------
        separation_mat: numpy.ndarray
            stain separation matrix as available in
            :py:mod:`skimage.color`, for information on how to create custom
            matrices see G. Landini's description for the corresponding
            `Fiji plugin <http://www.mecourse.com/landinig/software/cdeconv/cdeconv.html>`_
            (default: :py:attr:`skimage.color.hed_from_rgb`)

        Returns
        -------
        Tuple[tmlib.image.ChannelImage]
            separate channel image for each band

        References
        ----------
        .. _[1]: Ruifrok AC, Johnston DA. Quantification of histochemical staining by color deconvolution. Anal Quant Cytol Histol 23: 291-299, 2001 
        '''
        # TODO: metadata for brightfield images
        pxls = skimage.color.separate_stains(self.pixels, separation_mat)
        channel_img_1 = ChannelImage(pxls[:, :, 1], self.metadata)
        channel_img_2 = ChannelImage(pxls[:, :, 2], self.metadata)
        channel_img_3 = ChannelImage(pxls[:, :, 3], self.metadata)
        return (channel_img_1, channel_img_2, channel_img_3)


class StatsImage(Image):

    '''
    Class for a statistics image: a 2D greyscale image with a
    single band and data type float.
    '''

    def __init__(self, pixels=None, metadata=None):
        '''
        Initialize an instance of class StatsImage.

        Parameters
        ----------
        pixels: numpy.ndarray[float]
            pixels array (default: ``None``)
        metadata: tmlib.metadata.IllumstatsImageMetadata
            image metadata (default: ``None``)

        Returns
        -------
        StatsImage
            image object

        Raises
        ------
        ValueError
            when `pixels` has more than one band
        TypeError
            when `pixels` doesn't have float type
        '''
        super(StatsImage, self).__init__(pixels, metadata)
        if self.pixels is not None:
            if self.bands != 1:
                raise ValueError(
                        'Argument "pixels" must be a two-dimensional array '
                        'with 1 band.')
            if not self.is_float:
                raise TypeError(
                        'Argument "pixels" must have data type float.')

    def smooth(self, sigma):
        '''
        Apply a Gaussian smoothing filter to the pixels array.

        Parameters
        ----------
        sigma: int
            size of the standard deviation of the Gaussian kernel

        Returns
        -------
        tmlib.image.StatsImage
            image with smoothed pixels
        '''
        pxls = ndi.filters.gaussian_filter(self.pixels, sigma)
        return StatsImage(pxls, self.metadata)

    @staticmethod
    def create_from_file(filename, metadata):
        '''
        Not implemented.
        '''
        raise NotImplementedError(
                    'Class StatsImage doesn\'t have a '
                    '"create_from_file" method.')


class IllumstatsImages(object):

    '''
    Class that serves as a container for illumination statistics images.

    It provides the mean and standard deviation matrices for a given
    channel. The statistics are calculated at each pixel position over all
    image sites acquired in the same channel [1]_.

    References
    ----------
    .. [1] Stoeger T, Battich N, Herrmann MD, Yakimovich Y, Pelkmans L. 2015.
           Computer vision for image-based transcriptomics. Methods.
    '''

    def __init__(self, mean=None, std=None):
        self._mean = mean
        self._std = std

    @property
    def filename(self):
        '''
        Returns
        -------
        str
            absolute path to the file
        '''
        return self._filename

    @filename.setter
    def filename(self, value):
        self._filename = value

    @property
    def std(self):
        '''
        Returns
        -------
        tmlib.image.StatsImage
            image object for calculated standard deviation values
        '''
        if self._std is None:
            self._std = self._stats['std']
        return self._std

    @std.setter
    def std(self, value):
        if not isinstance(value, StatsImage):
            raise TypeError(
                    'Attribute "mean" must have type '
                    'tmlib.image.StatsImage')
        self._std = value

    @property
    def mean(self):
        '''
        Returns
        -------
        tmlib.image.StatsImage
            image object for calculated mean values
        '''
        if self._mean is None:
            self._mean = self._stats['mean']
        return self._mean

    @mean.setter
    def mean(self, value):
        if not isinstance(value, StatsImage):
            raise TypeError(
                    'Attribute "mean" must have type '
                    'tmlib.image.StatsImage')
        self._mean = value

    @property
    def metadata(self):
        '''
        Returns
        -------
        tmlib.metadata.IllumstatsImageMetadata
            metadata object
        '''
        return self._metadata

    @metadata.setter
    def metadata(self, value):
        if not isinstance(value, IllumstatsImageMetadata):
            raise TypeError(
                    'Attribute "metadata" must have type '
                    'tmlib.metadata.IllumstatsImageMetadata')
        self._metadata = value

    @cached_property
    def _stats(self):
        with DatasetReader(self.filename) as reader:
            mean = reader.read('stats/mean')
            std = reader.read('stats/std')
            tpoint = reader.read('metadata/tpoint')
            channel = reader.read('metadata/channel')
        if tpoint != self.metadata.tpoint:
            raise MetadataError('"tpoint" metadata is incorrect')
        if channel != self.metadata.channel:
            raise MetadataError('"channel" metadata is incorrect')
        return {
            'mean': StatsImage(pixels=mean, metadata=self.metadata),
            'std': StatsImage(pixels=std, metadata=self.metadata)
        }

    @staticmethod
    def create_from_file(filename, metadata):
        '''
        Create an Illumstats object from a file on disk.

        Parameters
        ----------
        filename: str
            absolute path to the file
        metadata: tmlib.metadata.IllumstatsImageMetadata
            metadata

        Returns
        -------
        tmlib.image.IllumstatsImages
            container for `StatsImage` objects
        '''
        stats = IllumstatsImages()
        stats.filename = filename
        stats.metadata = metadata
        return stats

    def smooth_stats(self, sigma=5):
        '''
        Smooth mean and standard deviation statistic matrices with a
        Gaussian filter. This is useful to prevent outliers pixels with
        extreme values to introduce artifacts into the image upon correction.

        Parameters
        ----------
        sigma: int, optional
            size of the standard deviation of the Gaussian kernel
            (default: ``5``)

        Note
        ----
        The matrices are modified in place.
        '''
        self.metadata.is_smoothed = True
        mean_pxls = self._stats['mean'].smooth(sigma).pixels
        self._stats['mean'] = StatsImage(
                                    pixels=mean_pxls,
                                    metadata=self.metadata)
        std_pxls = self._stats['std'].smooth(sigma).pixels
        self._stats['std'] = StatsImage(
                                    pixels=std_pxls,
                                    metadata=self.metadata)
