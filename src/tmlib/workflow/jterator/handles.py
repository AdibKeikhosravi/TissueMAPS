'''
A `Handle` instance describes a key-value pair which is either passed as
an argument to a Jterator module function or is returned by the function. The
approach can be considered a form of metaprogramming, where the object extends
the code of the actual module function via its properties and methods.
This is used to assert the correct type of arguments and return values and
enables storing data generated by modules to make it accessible outside the
scope of the module or retrieving data from the store when required by modules.
The object's attributes are specified as a mapping in a
`handles` YAML module input/output descriptor file.
'''
import sys
import numpy as np
import pandas as pd
import skimage
from abc import ABCMeta
from abc import abstractproperty
from abc import abstractmethod
from .. import utils
from ..image_utils import find_border_objects


class Handle(object):

    '''
    Abstract base class for a handle.
    '''

    __metaclass__ = ABCMeta

    @utils.assert_type(
        name='basestring', help='basestring')
    def __init__(self, name, help):
        '''
        Parameters
        ----------
        name: str
            name of the item, which must either match a parameter of the module
            function in case the item represents an input argument or the key
            of a key-value pair of the function's return value
        help: str
            help message
        '''
        self.name = name
        self.help = help

    @property
    def store(self):
        '''
        Returns
        -------
        dict
            in-memory key-value store
        '''
        return self._store


class InputHandle(Handle):

    '''
    Abstract base class for a handle whose value is used as an argument for
    a module function.
    '''

    __metaclass__ = ABCMeta

    def __init__(self, name, value, help):
        '''
        Parameters
        ----------
        name: str
            name of the item, which must match a parameter of the module
            function
        value:
            the actual argument of the module function parameter
        help: str
            help message
        '''
        super(InputHandle, self).__init__(name, help)
        self.value = value


class OutputHandle(Handle):

    '''
    Abstract base class for a handle whose value is returned by a module
    function.
    '''

    __metaclass__ = ABCMeta

    @utils.same_docstring_as(Handle.__init__)
    def __init__(self, name, help):
        super(OutputHandle, self).__init__(name, help)

    @abstractproperty
    def value(self):
        '''
        Returns
        -------
        value returned by module function
        '''
        pass


class PipeHandle(Handle):

    '''
    Abstract base class for a handle whose value that can be piped between
    objects.
    '''

    __metaclass__ = ABCMeta

    @utils.assert_type(key='basestring')
    def __init__(self, name, key, help):
        '''
        Parameters
        ----------
        name: str
            name of the item, which must either match a parameter of the module
            function in case the item represents an input argument or the key
            of a key-value pair of the function's return value
        key: str
            unique and hashable identifier; it serves as
            lookup identifier to retrieve the actual value of the item
        help: str
            help message

        '''
        super(PipeHandle, self).__init__(name, help)
        self.key = key

    @abstractproperty
    def value(self):
        '''
        The data that's returned by module function and possibly passed
        as an argument to other module functions
        '''
        pass


class Image(PipeHandle):

    '''
    Abstract base class for an image handle.
    '''

    __metaclass__ = ABCMeta

    @utils.same_docstring_as(PipeHandle.__init__)
    def __init__(self, name, key, help):
        super(Image, self).__init__(name, key, help)

    @abstractproperty
    def value(self):
        '''
        Returns
        -------
        numpy.ndarray
            2D pixels or 3D voxels array
        '''
        pass


class IntensityImage(Image):

    '''
    Class for an intensity image handle, where each
    pixel value in the image encodes an intensity.
    '''

    def __init__(self, name, key, help=''):
        '''
        Parameters
        ----------
        name: str
            name of the item, which must either match a parameter of the module
            function in case the item represents an input argument or the key
            of a key-value pair of the function's return value
        key: str
            unique and hashable identifier; it serves as
            lookup identifier to retrieve the actual value of the item
        help: str, optional
            help message (default: ``""``)
        '''
        super(Image, self).__init__(name, key, help)

    @property
    def value(self):
        '''
        Returns
        -------
        numpy.ndarray[uint 8 or uint16]
            2D pixels or 3D voxels array
        '''
        return self._value

    @value.setter
    def value(self, value):
        if not isinstance(value, np.ndarray):
            raise TypeError(
                    'Returned value for "%s" must have type numpy.ndarray.'
                    % self.name)
        if not(value.dtype == np.uint8 or value.dtype == np.uint16):
            raise TypeError(
                    'Returned value for "%s" must have data type '
                    'uint8 or uint16' % self.name)
        self._value = value


class LabelImage(Image):

    '''
    Class for a label image handle, where each pixel value in the image encodes
    is a unique label for a segmented object.
    '''

    @utils.same_docstring_as(IntensityImage.__init__)
    def __init__(self, name, key, help=''):
        super(Image, self).__init__(name, key, help)

    @property
    def value(self):
        '''
        Returns
        -------
        numpy.ndarray[int32]
            2D pixels or 3D voxels array
        '''
        return self._value

    @value.setter
    def value(self, value):
        if not isinstance(value, np.ndarray):
            raise TypeError(
                    'Returned value for "%s" must have type numpy.ndarray.'
                    % self.name)
        if not value.dtype == np.int32:
            raise TypeError(
                    'Returned value for "%s" must have data type int32'
                    % self.name)
        self._value = value


class BinaryImage(Image):

    '''
    Class for a binary image handle, where each pixel in the image encodes
    either background or foreground.
    '''

    @utils.same_docstring_as(IntensityImage.__init__)
    def __init__(self, name, key, help=''):
        super(Image, self).__init__(name, key, help)

    @property
    def value(self):
        '''
        Returns
        -------
        numpy.ndarray[int32]
            2D pixels or 3D voxels array
        '''
        return self._value

    @value.setter
    def value(self, value):
        if not isinstance(value, np.ndarray):
            raise TypeError(
                    'Returned value for "%s" must have type numpy.ndarray.'
                    % self.name)
        if value.dtype != np.bool:
            raise TypeError(
                    'Returned value for "%s" must have data type bool.'
                    % self.name)
        self._value = value


class Objects(LabelImage):

    @utils.assert_type(key='basestring')
    def __init__(self, name, key, help=''):
        '''
        Parameters
        ----------
        name: str
            name of the item
        key: str
            name that should be assigned to the objects
        '''
        super(Objects, self).__init__(name, key, help)
        self._features = list()
        self._attributes = list()

    @property
    def outlines(self):
        '''
        Returns
        -------
        List[pandas.DataFrame]
            outline coordinates of objects
        '''
        objects_ids = np.unique(self.value[self.value > 0])

        # Set border pixels to background to find complete contours of
        # objects at the border of the image
        self.value[0, :] = 0
        self.value[-1, :] = 0
        self.value[:, 0] = 0
        self.value[:, -1] = 0

        outlines = list()
        for i, obj_id in enumerate(objects_ids):
            # We could do this for all objects at once, but doing it for each
            # object individually ensures that we get the correct number of
            # objects and that the coordinates are in the correct order,
            # i.e. sorted by label
            obj_im = self.value == obj_id
            contours = skimage.measure.find_contours(
                            obj_im, 0.5, fully_connected='high')
            if len(contours) > 1:
                logger.warn('%d contours identified for object #%d',
                            len(contours), obj_id)
            contour = contours[0].astype(np.int64)
            outlines.append(
                pd.DataFrame({'y': contour[:, 0], 'x': contour[:, 1]})
            )
        return outlines

    @property
    def centroids(self):
        '''
        Returns
        -------
        List[pandas.DataFrame]
            centroid coordinates of objects
        '''
        regions = skimage.measure.regionprops(self.value)
        centroids = list()
        for r in regions:
            c = np.array(r.centroid).astype(np.int64)
            centroids.append(
                pd.DataFrame({'y': [c[0]], 'x': [c[1]]})
            )
        return centroids

    @property
    def is_border(self):
        '''
        Returns
        -------
        pandas.Series
            ``True`` if object lies at the border of the image and ``False``
            otherwise
        '''
        return pd.Series(find_border_objects(self.value), name='is_border')

    @property
    def parent_name(self):
        '''
        Returns
        -------
        str
            name of the parent objects
        '''
        return self._parent_name

    @parent_name.setter
    def parent_name(self, value):
        if not isinstance(value, basestring):
            raise TypeError(
                    'Attribute "parent_name" must have type basestring.')
        self._parent_name = value

    @property
    def attributes(self):
        '''
        Returns
        -------
        List[pandas.Series]
            collection of attributes for segmented objects
        '''
        return self._attributes

    def add_attributes(self, value):
        '''
        Add additional attribute.

        Parameters
        ----------
        value: pandas.Series
            attribute for for each segmented object

        See also
        --------
        :py:attrbute:`tmlib.jterator.handles.Attribute.value`
        '''
        if not isinstance(value, pd.Series):
            raise TypeError(
                    'Attribute "attributes" must have type pandas.Series.')
        self._attributes.append(value)

    @property
    def features(self):
        '''
        Returns
        -------
        List[pandas.DataFrame]
            collection of features for segmented objects
        '''
        return self._features

    def add_features(self, value):
        '''
        Add additional features.

        Parameters
        ----------
        value: pandas.DataFrame
            features for each object in `image`

        See also
        --------
        :py:attrbute:`tmlib.jterator.handles.Features.value`
        '''
        self._features.append(value)

    # def put(self):
    #     '''
    #     Store objects.
    #     '''
    #     self.store['pipe'][self.key] = self.valu
    #     for i, item in enumerate(self.outlines):
    #         path = '{objects_name}/{type}/{name}'.format(
    #                     objects_name=self.key,
    #                     type='coordinates',
    #                     name='outlines/id%d' % i)
    #         self.store['persistent'][path] = item
    #     for i, item in enumerate(self.centroids):
    #         path = '{objects_name}/{type}/{name}'.format(
    #                     objects_name=self.key,
    #                     type='coordinates',
    #                     name='centroids/id%d' % i)
    #         self.store['persistent'][path] = item
    #     path = '{objects_name}/{type}/{name}'.format(
    #                     objects_name=self.key,
    #                     type='attributes',
    #                     name='is_border')
    #     self.store['persistent'][path] = self.is_border


class Scalar(InputHandle):

    '''
    Class for a input handle that provides a scalar argument.
    '''

    @utils.assert_type(value={'int', 'float', 'basestring', 'bool'})
    def __init__(self, name, value, options=[], help=''):
        '''
        Parameters
        ----------
        name: str
            name of the item, which must match a parameter of the module
            function
        value: str or int or float or bool
            value of the item, i.e. the actual argument of the function
            parameter
        help: str, optional
            help message (default: ``""``)
        '''
        if options:
            if value is not None:
                if value not in options:
                    raise ValueError(
                            'Argument "value" can be either "%s"'
                            % '" or "'.join(options))
        super(Scalar, self).__init__(name, value, help)
        self.options = options


class Sequence(InputHandle):

    '''
    Class for a input handle that provides a sequence argument.
    '''

    @utils.assert_type(value={'list'})
    def __init__(self, name, value, help=''):
        '''
        Parameters
        ----------
        name: str
            name of the item, which must match a parameter of the module
            function
        mode: str
            mode of the item, which defines the way it can be handled by the
            program
        value: List[str or int or float]
            value of the item, i.e. the actual argument of the function
            parameter
        help: str, optional
            help message (default: ``""``)
        '''
        for v in value:
            if all([not isinstance(v, t) for t in {int, float, basestring}]):
                raise TypeError(
                        'Elements of argument "value" must have type '
                        'int, float, or str.')
        super(Sequence, self).__init__(name, value, help)


class Plot(InputHandle):

    '''
    Class for a handle that provides a boolean argument to indicate to the
    module function whether a figure should be generated.
    '''

    @utils.assert_type(value='bool')
    def __init__(self, name, value=False, help=''):
        '''
        Parameters
        ----------
        name: str
            name of the item, which must match a parameter of the module
            function
        value: bool, optional
            whether plotting should be activated (default: ``False``)
        help: str, optional
            help message (default: ``""``)
        '''
        super(Plot, self).__init__(name, value, help)


class Features(OutputHandle):

    '''
    Class for an output handle whose value is a two-dimensional labeled
    array with *n* columns of type ``float``, where *n* is the number of
    features that were extracted for the referenced segmented objects.
    '''

    @utils.assert_type(
                objects_ref='basestring',
                channel_ref={'basestring', 'NoneType'})
    def __init__(self, name, objects_ref, channel_ref=None, help=''):
        '''
        Parameters
        ----------
        name: str
            name of the item, which must match a parameter of the module
            function
        objects_ref: str
            reference to the objects for which features were extracted
        channel_ref: str
            reference to the channel from which features were extracted
        help: str, optional
            help message (default: ``""``)
        '''
        super(Features, self).__init__(name, help)
        self.objects_ref = objects_ref
        self.channel_ref = channel_ref

    @property
    def value(self):
        '''
        Returns
        -------
        pandas.DataFrame
            features of segmented objects
        '''
        return self._value

    @value.setter
    def value(self, value):
        if not isinstance(value, pd.DataFrame):
            raise TypeError(
                    'Returned value of "%s" must have type pandas.DataFrame.'
                    % self.name)
        if value.values.dtype != float:
            raise TypeError(
                    'Returned value of "%s" must have data type float.'
                    % self.name)
        self._value = value


class Attribute(OutputHandle):

    '''
    Class for an output handle whose value is a one-dimensional labeled
    array with arbitrary type that describes a characteristic of
    the referenced segmented objects.
    '''

    @utils.assert_type(objects_ref='basestring')
    def __init__(self, name, objects_ref, help=''):
        '''
        Parameters
        ----------
        name: str
            name of the item, which must match a parameter of the module
            function
        objects_ref: str
            reference to the objects that the attribute characterizes
        help: str, optional
            help message (default: ``""``)
        '''
        super(Attribute, self).__init__(name, help)
        self.objects_ref = objects_ref

    @property
    def value(self):
        '''
        Returns
        -------
        pandas.Series
            attribute of segmented objects
        '''
        return self._value

    @value.setter
    def value(self, value):
        if not isinstance(value, pd.Series):
            raise TypeError(
                    'Returned value of "%s" must have type pandas.Series.'
                    % self.name)
        if isinstance(value.name, basestring):
            raise ValueError(
                    'The attribute "name" of the returned value of "%s" '
                    'must have type basestring.' % self.name)
        self._value = value


class Figure(OutputHandle):

    '''
    Class for an output handle whose value is a HTML string that represents
    a figure created by a module and can be written to a file.
    '''

    def __init__(self, name, help=''):
        '''
        Parameters
        ----------
        name: str
            name of the item, which must match a parameter of the module
            function
        key: str
            name that should be given to the objects 
        help: str, optional
            help message (default: ``""``)
        '''
        super(Figure, self).__init__(name, help)

    @property
    def value(self):
        '''
        Returns
        -------
        str
            HTML representation of a figure
        '''
        return self._value

    @value.setter
    def value(self, value):
        if not isinstance(value, basestring):
            raise TypeError(
                    'Returned value of "%s" must have type basestring.'
                    % self.name)
        # TODO: Additional checks to make sure the string encodes HTML?
        self._value = str(value)


def create_handle(type, **kwargs):
    '''
    Factory function to create an instance of an implementation of the
    :py:class:`tmlib.jterator.handles.Handle` abstract base class.

    Parameters
    ----------
    type: str
        type of the handle item; must match a name of one of the
        implemented classes in this module
    **kwargs: dict
        arguments that are passed to the constructor of the class

    Returns
    -------
    tmlib.jterator.handles.Handle

    Raises
    ------
    AttributeError
        when `type` is not a valid class name
    TypeError
        when an unexpected keyword is passed to the constructor of the class
    '''
    current_module = sys.modules[__name__]
    try:
        class_object = getattr(current_module, type)
    except AttributeError:
        raise AttributeError('Type "%s" is not a valid class name.' % type)
    return class_object(**kwargs)
