from ..args import VariableArgs


class JteratorInitArgs(VariableArgs):

    def __init__(self, **kwargs):
        '''
        Initialize an instance of class JteratorInitArgs.

        Parameters
        ----------
        **kwargs: dict
            arguments as key-value pairs
        '''
        self.merge = self._merge_params['default']
        super(JteratorInitArgs, self).__init__(**kwargs)

    @property
    def _persistent_attrs(self):
        return {'pipeline', 'merge'}

    @property
    def merge(self):
        '''
        Returns
        -------
        bool
            indicator whether output data should be merged with data generated
            by previous pipelines

        Warning
        -------
        When ``False`` data of previous pipelines will be deleted.
        '''
        return self._merge

    @merge.setter
    def merge(self, value):
        if not isinstance(value, self._merge_params['type']):
            raise TypeError('Argument "merge" must have type %s'
                            % self._merge_params['type'])
        self._merge = value

    @property
    def _merge_params(self):
        return {
            'default': False,
            'type': bool,
            'help': '''
                merge output with data generated by previous pipelines to
                prevent that data is overwritten
            '''
        }

    @property
    def pipeline(self):
        '''
        Returns
        -------
        str
            name of the pipeline that should be processed
        '''
        return self._pipeline

    @pipeline.setter
    def pipeline(self, value):
        if not isinstance(value, self._pipeline_params['type']):
            raise TypeError('Argument "pipeline" must have type %s'
                            % self._pipeline_params['type'])
        self._pipeline = value

    @property
    def _pipeline_params(self):
        return {
            'type': str,
            'required': True,
            'help': '''
                name of the pipeline that should be processed
            '''
        }


class JteratorRunArgs(VariableArgs):

    def __init__(self, **kwargs):
        '''
        Initialize an instance of class JteratorRunArgs.

        Parameters
        ----------
        **kwargs: dict
            arguments as key-value pairs
        '''
        self.plot = self._plot_params['default']
        super(JteratorRunArgs, self).__init__(**kwargs)

    @property
    def _required_args(self):
        return {'pipeline'}

    @property
    def _persistent_attrs(self):
        return {'pipeline', 'plot'}

    @property
    def plot(self):
        '''
        Returns
        -------
        bool
            indicator that modules should generate plots (default: ``False``)
        '''
        return self._plot

    @plot.setter
    def plot(self, value):
        if not isinstance(value, self._plot_params['type']):
            raise TypeError('Attribute "plot" must have type %s.'
                            % self._plot_params['type'])
        self._plot = value

    @property
    def _plot_params(self):
        return {
            'type': bool,
            'default': False,
            'help': '''
                activate plotting
            '''

        }

    @property
    def pipeline(self):
        '''
        Returns
        -------
        str
            name of the pipeline that should be processed
        '''
        return self._pipelines

    @pipeline.setter
    def pipeline(self, value):
        if not isinstance(value, self._pipeline_params['type']):
            raise TypeError('Argument "pipeline" must have type %s'
                            % self._pipeline_params['type'])
        self._pipeline = value

    @property
    def _pipeline_params(self):
        return {
            'type': str,
            'help': '''
                name of the pipeline that should be processed
            '''
        }


class JteratorSubmitArgs(VariableArgs):

    def __init__(self, **kwargs):
        '''
        Initialize an instance of class JteratorSubmitArgs.

        Parameters
        ----------
        **kwargs: dict
            arguments as key-value pairs
        '''
        super(JteratorSubmitArgs, self).__init__(**kwargs)

    @property
    def _required_args(self):
        return {'pipeline'}

    @property
    def _persistent_attrs(self):
        return {'pipeline'}

    @property
    def pipeline(self):
        '''
        Returns
        -------
        str
            name of the pipeline that should be processed
        '''
        return self._pipelines

    @pipeline.setter
    def pipeline(self, value):
        if not isinstance(value, self._pipeline_params['type']):
            raise TypeError('Argument "pipeline" must have type %s'
                            % self._pipeline_params['type'])
        self._pipeline = value

    @property
    def _pipeline_params(self):
        return {
            'type': str,
            'help': '''
                name of the pipeline that should be processed
            '''
        }


class JteratorResubmitArgs(VariableArgs):

    def __init__(self, **kwargs):
        '''
        Initialize an instance of class JteratorResubmitArgs.

        Parameters
        ----------
        **kwargs: dict
            arguments as key-value pairs
        '''
        super(JteratorResubmitArgs, self).__init__(**kwargs)

    @property
    def _required_args(self):
        return {'pipeline'}

    @property
    def _persistent_attrs(self):
        return {'pipeline'}

    @property
    def pipeline(self):
        '''
        Returns
        -------
        str
            name of the pipeline that should be processed
        '''
        return self._pipelines

    @pipeline.setter
    def pipeline(self, value):
        if not isinstance(value, self._pipeline_params['type']):
            raise TypeError('Argument "pipeline" must have type %s'
                            % self._pipeline_params['type'])
        self._pipeline = value

    @property
    def _pipeline_params(self):
        return {
            'type': str,
            'help': '''
                name of the pipeline that should be processed
            '''
        }


class JteratorCollectArgs(VariableArgs):

    def __init__(self, **kwargs):
        '''
        Initialize an instance of class JteratorCollectArgs.

        Parameters
        ----------
        **kwargs: dict
            arguments as key-value pairs
        '''
        super(JteratorCollectArgs, self).__init__(**kwargs)

    @property
    def _required_args(self):
        return {'pipeline'}

    @property
    def _persistent_attrs(self):
        return {'pipeline'}

    @property
    def pipeline(self):
        '''
        Returns
        -------
        str
            name of the pipeline that should be processed
        '''
        return self._pipelines

    @pipeline.setter
    def pipeline(self, value):
        if not isinstance(value, self._pipeline_params['type']):
            raise TypeError('Argument "pipeline" must have type %s'
                            % self._pipeline_params['type'])
        self._pipeline = value

    @property
    def _pipeline_params(self):
        return {
            'type': str,
            'help': '''
                name of the pipeline that should be processed
            '''
        }


class JteratorLogArgs(VariableArgs):

    def __init__(self, **kwargs):
        '''
        Initialize an instance of class JteratorLogArgs.

        Parameters
        ----------
        **kwargs: dict
            arguments as key-value pairs
        '''
        super(JteratorLogArgs, self).__init__(**kwargs)

    @property
    def _required_args(self):
        return {'pipeline'}

    @property
    def _persistent_attrs(self):
        return {'pipeline'}

    @property
    def pipeline(self):
        '''
        Returns
        -------
        str
            name of the pipeline that should be processed
        '''
        return self._pipelines

    @pipeline.setter
    def pipeline(self, value):
        if not isinstance(value, self._pipeline_params['type']):
            raise TypeError('Argument "pipeline" must have type %s'
                            % self._pipeline_params['type'])
        self._pipeline = value

    @property
    def _pipeline_params(self):
        return {
            'type': str,
            'help': '''
                name of the pipeline that should be processed
            '''
        }


class JteratorInfoArgs(VariableArgs):

    def __init__(self, **kwargs):
        '''
        Initialize an instance of class JteratorInfoArgs.

        Parameters
        ----------
        **kwargs: dict
            arguments as key-value pairs
        '''
        super(JteratorInfoArgs, self).__init__(**kwargs)

    @property
    def _required_args(self):
        return {'pipeline'}

    @property
    def _persistent_attrs(self):
        return {'pipeline'}

    @property
    def pipeline(self):
        '''
        Returns
        -------
        str
            name of the pipeline that should be processed
        '''
        return self._pipelines

    @pipeline.setter
    def pipeline(self, value):
        if not isinstance(value, self._pipeline_params['type']):
            raise TypeError('Argument "pipeline" must have type %s'
                            % self._pipeline_params['type'])
        self._pipeline = value

    @property
    def _pipeline_params(self):
        return {
            'type': str,
            'help': '''
                name of the pipeline that should be processed
            '''
        }


class JteratorCreateArgs(VariableArgs):

    def __init__(self, **kwargs):
        '''
        Initialize an instance of class JteratorCreateArgs.

        Parameters
        ----------
        **kwargs: dict
            arguments as key-value pairs
        '''
        self.repo_dir = self._repo_dir_params['default']
        self.skel_dir = self._skel_dir_params['default']
        super(JteratorCreateArgs, self).__init__(**kwargs)

    @property
    def _required_args(self):
        return {'pipeline'}

    @property
    def _persistent_attrs(self):
        return {'pipeline', 'repo_dir', 'skel_dir'}

    @property
    def repo_dir(self):
        '''
        Returns
        -------
        str
            path to repository directory where module files are located
        '''
        return self._repo_dir

    @repo_dir.setter
    def repo_dir(self, value):
        if not(isinstance(value, self._repo_dir_params['type']) or
                value is None):
            raise TypeError('Attribute "repo_dir" must have type %s'
                            % self._repo_dir_params['type'])
        self._repo_dir = value

    @property
    def _repo_dir_params(self):
        return {
            'type': str,
            'default': None,
            'help': '''
                path to repository directory where module files are located
            '''
        }

    @property
    def skel_dir(self):
        '''
        Returns
        -------
        str
            path to a directory that represents a project skeleton 
        '''
        return self._skel_dir

    @skel_dir.setter
    def skel_dir(self, value):
        if not(isinstance(value, self._skel_dir_params['type']) or
                value is None):
            raise TypeError('Attribute "skel_dir" must have type %s'
                            % self._skel_dir_params['type'])
        self._skel_dir = value

    @property
    def _skel_dir_params(self):
        return {
            'type': str,
            'default': None,
            'help': '''
                path to repository directory where module files are located
            '''
        }

    @property
    def pipeline(self):
        '''
        Returns
        -------
        str
            name of the pipeline that should be processed
        '''
        return self._pipelines

    @pipeline.setter
    def pipeline(self, value):
        if not isinstance(value, self._pipeline_params['type']):
            raise TypeError('Argument "pipeline" must have type %s'
                            % self._pipeline_params['type'])
        self._pipeline = value

    @property
    def _pipeline_params(self):
        return {
            'type': str,
            'help': '''
                name of the pipeline that should be processed
            '''
        }


class JteratorCheckArgs(VariableArgs):

    def __init__(self, **kwargs):
        '''
        Initialize an instance of class JteratorCheckArgs.

        Parameters
        ----------
        **kwargs: dict
            arguments as key-value pairs
        '''
        super(JteratorCheckArgs, self).__init__(**kwargs)

    @property
    def _required_args(self):
        return {'pipeline'}

    @property
    def _persistent_attrs(self):
        return {'pipeline'}

    @property
    def pipeline(self):
        '''
        Returns
        -------
        str
            name of the pipeline that should be processed
        '''
        return self._pipelines

    @pipeline.setter
    def pipeline(self, value):
        if not isinstance(value, self._pipeline_params['type']):
            raise TypeError('Argument "pipeline" must have type %s'
                            % self._pipeline_params['type'])
        self._pipeline = value

    @property
    def _pipeline_params(self):
        return {
            'type': str,
            'help': '''
                name of the pipeline that should be processed
            '''
        }


class JteratorRemoveArgs(VariableArgs):

    def __init__(self, **kwargs):
        '''
        Initialize an instance of class JteratorRemoveArgs.

        Parameters
        ----------
        **kwargs: dict
            arguments as key-value pairs
        '''
        super(JteratorRemoveArgs, self).__init__(**kwargs)

    @property
    def _required_args(self):
        return {'pipeline'}

    @property
    def _persistent_attrs(self):
        return {'pipeline'}

    @property
    def pipeline(self):
        '''
        Returns
        -------
        str
            name of the pipeline that should be processed
        '''
        return self._pipelines

    @pipeline.setter
    def pipeline(self, value):
        if not isinstance(value, self._pipeline_params['type']):
            raise TypeError('Argument "pipeline" must have type %s'
                            % self._pipeline_params['type'])
        self._pipeline = value

    @property
    def _pipeline_params(self):
        return {
            'type': str,
            'help': '''
                name of the pipeline that should be processed
            '''
        }
