#!/usr/bin/env python
import os
import logging
import argparse
import subprocess
import sys
import collections

from tmsetup.config import Setup, load_inventory
from tmsetup.log import configure_logging, map_logging_verbosity


def run(command):
    process = subprocess.Popen(command, stdout=subprocess.PIPE)
    for c in iter(lambda: process.stdout.read(1), ''):
        sys.stdout.write(c)


def build_ansible_commands(args):
    logger.info('build Ansible commands')
    setup = Setup()
    dynamic_inventory_file = os.path.abspath(
        os.path.join(__file__, '..', 'inventory.py')
    )
    inventory = load_inventory()
    commands = list()
    included_hosts = collections.defaultdict(set)
    for cluster in setup.grid.clusters:
        for category in cluster.categories:
            for group in category.groups:
                if group.name in included_hosts:
                    raise SetupDescriptionError(
                        'Group "%s" is duplicated in setup description.' %
                        group.name
                    )
                all_hosts = [item[0] for item in inventory.items(group.name)]
                if args.groups:
                    if group.name in args.groups:
                        included_hosts[group.name].union(set(all_hosts))
                elif args.hosts:
                    for host in args.hosts:
                        if host in group_hosts:
                            included_hosts[group.name].add(host)
                elif args.cluster:
                    if args.cluster == cluster.name:
                        if (args.category is None or
                                args.category == category.name):
                            included_hosts[group.name].union(set(all_hosts))
                else:
                    included_hosts[group.name].union(set(all_hosts))
                if args.action == 'deploy':
                    if group.name in included_hosts:
                        logger.info('deploy Ansible host group "%s"', group.name)
                        # NOTE: variables are already provided via group_vars
                        # files
                        cmd = _build_command(
                            args.verbosity, dynamic_inventory_file,
                            group.playbook, dict(), included_hosts[group.name]
                        )
                        commands.append(cmd)

    if args.action in {'launch', 'terminate', 'start', 'stop'}:
        playbook_file = os.path.abspath(
            os.path.join(
                __file__, '..', '..', '..', 'playbooks', 'instances.yml'
            )
        )
        if args.action == 'launch':
            logger.info('launch virtual machines')
            variables = {'instance_state': 'present'}
        elif args.action == 'terminate':
            logger.info('terminate virtual machines')
            variables = {'instance_state': 'absent'}
        elif args.action == 'start':
            # TODO: dependent on cloud provider
            # ec2: started
            # gce: running
            # os: -
            raise ValueError('Starting VMs is not yet supported')
            # variables = 'instance_state=running'
        elif args.action == 'stop':
            # TODO: dependent on cloud provider
            # ec2: stopped
            # gce: stopped
            # os: -
            raise ValueError('Stopping VMs is not yet supported')
            # variables = 'instance_state=stopped'
        cmd = _build_command(
            args.verbosity, dynamic_inventory_file,
            playbook_file, variables, reduce(set.union, included_hosts.values())
        )
        commands.append(cmd)

    return commands


def _build_command(verbosity, inventory, playbook, variables, hosts):
    var_strings = list()
    for k, v in variables.iteritems():
        var_strings.append('='.join([k, v]))
    cmd = [
        'ansible-playbook',
        '-i', inventory,
        playbook,
    ]
    if verbosity > 0:
        cmd.append('-%s' % (verbosity * 'v'))
    if variables:
        cmd.extend(['-e', '"%s"' % ','.join(var_strings)])
    if hosts:
        import ipdb; ipdb.set_trace()
        cmd.extend(['--limit', ','.join(hosts)])
    return cmd


def main(args):
    # TODO: let inventory save playbook locations into file
    commands = build_ansible_commands(args)
    logger.info('run Ansible commands')
    for cmd in commands:
        logger.debug(' '.join(cmd))
        run(cmd)


if __name__ == '__main__':

    def check_dependency(required_arg, forbidden_args={}):
        class ArgumentDependencyAction(argparse.Action):
            def __call__(self, parser, namespace, values, option_string=None):
                if getattr(namespace, required_arg) is None:
                    parser.error(
                        'Argument "--%s" also requires "--%s".' % (
                            self.dest, required_arg
                        )
                    )
                elif forbidden_args:
                    for arg in forbidden_args:
                        if getattr(namespace, arg) is not None:
                            parser.error(
                                'Argument "--%s" cannot be used together with '
                                ' "--%s".' % (self.dest, arg)
                            )
                else:
                    setattr(namespace, self.dest, values)
        return ArgumentDependencyAction


    parser = argparse.ArgumentParser(
        description='Setup TissueMAPS on Ubuntu.'
    )
    parser.add_argument(
        '--verbosity', '-v', action='count', default=0,
        help='increase logging verbosity'
    )
    target_group = parser.add_mutually_exclusive_group()
    target_group.add_argument(
        '--hosts', metavar='NAME', nargs='+', type=str, default=set(),
        help='limit action to individual VMs'
    )
    target_group.add_argument(
        '--cluster', metavar='NAME', type=str,
        help='limit action to VMs of a particular cluster'
    )
    target_group.add_argument(
        '--groups', metavar='NAME', nargs='+', type=str, default=set(),
        help='limit action to individual Ansible groups'
    )
    parser.add_argument(
        '--category', dest='category', metavar='NAME', type=str,
        action=check_dependency('cluster', {'groups', 'hosts'}),
        help='limit action to VMs of a partiuclar cluster category'
    )

    subparsers = parser.add_subparsers(dest='action', help='action')
    subparsers.required = True

    launch_subparser = subparsers.add_parser(
        'launch',
        help='launch virtual machine (VM) instances'
    )
    launch_subparser.set_defaults(method='launch')
    launch_subparser.description = 'Launch virtual machine instances.'

    terminate_subparser = subparsers.add_parser(
        'terminate',
        help='terminate virtual machine (VM) instances'
    )
    terminate_subparser.set_defaults(method='terminate')
    terminate_subparser.description = 'Terminate virtual machine instances.'

    # TODO: start/stop subparsers

    deploy_subparser = subparsers.add_parser(
        'deploy',
        help='deploy application on virtual machine (VM) instances'
    )
    deploy_subparser.set_defaults(method='deploy')
    deploy_subparser.description = '''
        Deploy application on virtual machine instances.
    '''

    args = parser.parse_args()
    args.hosts = set(args.hosts)
    args.groups = set(args.groups)

    configure_logging()
    log_level = map_logging_verbosity(args.verbosity)
    logger = logging.getLogger(os.path.basename(__file__))
    logger.setLevel(log_level)
    tmsetup_logger = logging.getLogger('tmsetup')
    tmsetup_logger.setLevel(log_level)

    main(args)
