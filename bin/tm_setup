#!/usr/bin/env python
import os
import logging
import argparse
import subprocess
import sys
import yaml
import collections
from whichcraft import which
from pkg_resources import resource_filename, resource_exists

import tmsetup
from tmsetup.config import Setup
from tmsetup.inventory import build_inventory_information
from tmsetup.log import configure_logging, map_logging_verbosity
from tmsetup.inventory import HOSTNAME_FORMAT
from tmsetup.errors import SetupDescriptionError
from tmsetup.utils import to_yaml, to_json

logger = logging.getLogger(os.path.basename(__file__))

REQUIRED_TM_GROUPS = {
    'tissuemaps_server', 'tissuemaps_db_master', 'tissuemaps_db_worker'
}

SUPPORTED_TM_GROUPS = REQUIRED_TM_GROUPS.union({'tissuemaps_compute'})

SUPPORTED_EC_GROUPS = {
    'ganglia_server', 'ganglia_client',
    'glusterfs_server',
    'slurm_master', 'slurm_workers'
}

SUPPORTED_GROUPS = SUPPORTED_TM_GROUPS.union(SUPPORTED_EC_GROUPS)


def _get_playbooks_dir(pkg_name):
    logger.debug('get playbooks directory for "%s" package', pkg_name)
    if pkg_name == 'elasticluster':
        try:
            import elasticluster
        except ImportError:
            logger.error('package "elasticluster" is not installed')
            sys.exit(1)
    rel_path = os.path.join('share', 'playbooks')
    path = os.path.abspath(resource_filename(pkg_name, rel_path))
    if not os.path.exists(path):
        logger.error('playbooks directory does not exist: %s', path)
        sys.exit(1)
    return path


def get_host_groups():
    logger.info('build Ansible commands')
    setup = Setup()
    groups_to_deploy = collections.defaultdict(list)
    for cluster in setup.architecture.clusters:
        for node_type in cluster.node_types:
            for group in node_type.groups:
                if group.name not in SUPPORTED_GROUPS:
                    logger.error(
                        'unsupported Ansible host group: %s', group.name
                    )
                    sys.exit(1)
                logger.info('include Ansible host group: %s', group.name)
                groups_to_deploy[group.name].append(group.playbook)

    for group_name in REQUIRED_TM_GROUPS:
        if group_name not in groups_to_deploy.keys():
            logger.error('missing required Ansible host group: %s', group_name)
            sys.exit(1)

    return groups_to_deploy


def _build_container_commands(action, verbosity):
    commands = list()
    playbooks_dir = _get_playbooks_dir('tmsetup')
    roles_dir = os.path.join(playbooks_dir, 'roles')
    vars_dir = os.path.join(playbooks_dir, 'group_vars')
    project_dir = os.path.join(playbooks_dir, '../container/projects/tissuemaps')
    cmd = _build_ansible_container_command(
        action, verbosity, project_dir, roles_dir, vars_dir
    )
    return [cmd]


def _build_ansible_container_command(action, verbosity,
        project_dir, roles_dir, vars_dir):
    cmd = ['ansible-container', '--project', os.path.abspath(project_dir)]
    group_dirs = os.listdir(vars_dir)
    # NOTE: Ansible variables {{ }} declared in files are not expanded!
    for group in group_dirs:
        filename = os.path.abspath(os.path.join(vars_dir, group, 'vars.yml'))
        cmd.extend(['--var-file', filename])
    if verbosity > 3:
        cmd.append('--debug')
    if action in {'build', 'start', 'stop'}:
        if action == 'build':
            cmd.extend([
                'build', '--from-scratch',
                '--roles-path', os.path.abspath(roles_dir)
            ])
        elif action == 'start':
            cmd.extend([
                'run', '--production', '--detached',
                '--roles-path', os.path.abspath(roles_dir)
            ])
        elif action == 'stop':
            cmd.append('stop')
        if action == 'build':
            # The following options are parsed to the "ansible-playbooks" command.
            cmd.append('--')
            if verbosity > 0:
                verbosity -= 1
                if verbosity > 0:
                    cmd.append('-%s' % (verbosity * 'v'))
            variables = collections.OrderedDict()
            for group in group_dirs:
                filename = os.path.abspath(
                    os.path.join(vars_dir, group, 'vars.yml')
                )
                with open(filename) as f:
                    for line in f.readlines():
                        var_mapping = yaml.load(line)
                        if var_mapping is None:
                            continue
                        for k, v in var_mapping.iteritems():
                            variables[k] = v
            for k, v in variables.iteritems():
                cmd.append('-e')
                var_string = '='.join([k, str(v)])
                # Values should not get quoted because this breaks
                # the docker-compose.yml Jinja templating approach of
                # ansible-container.
                cmd.append('%s' % var_string)
    elif action == 'push':
        # TODO: pass user/organization and tag as arguments
        logger.info('pushing container images to Docker Hub')
        # NOTE: This works only with write access to the "tissuemaps"
        # organization on Docker Hub.
        cmd.extend([
            'push', '--push-to', 'tissuemaps', '--tag', 'latest',
            '--roles-path', os.path.abspath(roles_dir)
        ])
    else:
        logger.error('unsupported action for containers: %s', action)
        sys.exit(1)
    return cmd


def _build_vm_commands(action, verbosity, groups_to_deploy):
    commands = list()
    variables = dict()
    if action in {'launch', 'terminate', 'start', 'stop'}:
        if action == 'launch':
            logger.info('launch virtual machines')
            variables['instance_state'] = 'present'
        elif action == 'terminate':
            logger.info('terminate virtual machines')
            variables['instance_state'] = 'absent'
        elif action == 'start':
            # TODO: functionality not yet supported by OpenStack modules
            # ec2: started
            # gce: running
            # os: -
            logger.error('starting VMs is not yet supported')
            sys.exit(1)
        elif action == 'stop':
            # TODO: functionality not yet supported by OpenStack modules
            # ec2: stopped
            # gce: stopped
            # os: -
            logger.error('stopping VMs is not yet supported')
            sys.exit(1)
        # First refresh inventory
        if args.refresh_cache:
            commands.append(['tm_inventory', '--refresh'])
        tmsetup_playbooks_dir = _get_playbooks_dir('tmsetup')
        playbook = os.path.join(tmsetup_playbooks_dir, 'instance.yml')
        cmd = _build_ansible_vm_command(
            verbosity, playbook, variables, set(groups_to_deploy)
        )
        commands.append(cmd)

    elif action == 'deploy':
        # This playbook must be called after the individual components have
        # been built.
        # First refresh inventory
        if args.refresh_cache:
            commands.append(['tm_inventory', '--refresh'])

        # We need to run elasticluster playbooks only in case groups
        # are provided that are not supported by tmsetup.
        run_elasticluster = False
        for group in groups_to_deploy.keys():
            if group not in SUPPORTED_TM_GROUPS:
                run_elasticluster = True
        if run_elasticluster:
            # NOTE: This playbook also configures SSH host-based authentication,
            # so it's a bad idea to run this only on a subset of groups!
            elasticluster_playbooks_dir = _get_playbooks_dir('elasticluster')
            playbook = os.path.join(elasticluster_playbooks_dir, 'site.yml')
            logger.debug('build command for playbook: %s', playbook)
            cmd = _build_ansible_vm_command(
                verbosity, playbook, variables, set(groups_to_deploy.keys())
            )
            cmd.extend(['-e', 'ansible_become=yes'])
            commands.append(cmd)

        # Run the TissueMAPS-specific playbooks implemented in tmsetup
        tmsetup_playbooks_dir = _get_playbooks_dir('tmsetup')
        playbook = os.path.join(tmsetup_playbooks_dir, 'site.yml')
        logger.debug('build command for playbook: %s', playbook)
        cmd = _build_ansible_vm_command(
            verbosity, playbook, variables, set(groups_to_deploy.keys())
        )
        cmd.extend(['-e', 'ansible_become=yes'])
        commands.append(cmd)

        for group, plays in groups_to_deploy.iteritems():
            for playbook in plays:
                if playbook is not None:
                    cmd = _build_ansible_vm_command(verbosity, playbook)
                    commands.append(cmd)

    else:
        logger.error('unsupported action for VMs: %s', action)
        sys.exit(1)

    return commands


def _build_ansible_vm_command(verbosity, playbook, variables=dict(), hosts=set()):
    var_strings = list()
    for k, v in variables.iteritems():
        var_strings.append('='.join([k, v]))
    # The "tm_inventory" script should be on the path upon installation.
    inventory_file = which('tm_inventory')
    cmd = ['ansible-playbook', '-i', inventory_file, playbook]
    if verbosity > 0:
        verbosity -= 1
        if verbosity > 0:
            cmd.append('-%s' % (verbosity * 'v'))
    # It's important that these strings get quoted for security reasons.
    if variables:
        cmd.extend(['-e', '%s' % ','.join(var_strings)])
    if hosts:
        cmd.extend(['--limit', '%s' % ','.join(hosts)])
    return cmd


def _run(command):
    logger.debug('command: %s' % ' '.join(command))
    process = subprocess.Popen(command, stdout=subprocess.PIPE)
    for c in iter(lambda: process.stdout.read(1), ''):
        sys.stdout.write(c)


def container_manage(args):
    commands = _build_container_commands(args.action, args.verbosity)
    logger.info('run Ansible commands')
    for cmd in commands:
        _run(cmd)


def vm_manage(args):
    groups = get_host_groups()
    commands = _build_vm_commands(args.action, args.verbosity, groups)
    logger.info('run Ansible commands')
    for cmd in commands:
        _run(cmd)


def vm_show(args):
    groups = get_host_groups()
    setup = Setup()
    inventory_info = build_inventory_information(setup)
    print to_yaml(inventory_info)


def main(args):
    context = globals()
    func = context.get(args.function)
    func(args)


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        description='Setup TissueMAPS on virtual machines or containers.'
    )
    parser.add_argument(
        '--verbosity', '-v', action='count', default=0,
        help='increase logging verbosity'
    )

    subparsers = parser.add_subparsers(dest='env', help='environment')
    subparsers.required = True

    vm_parser = subparsers.add_parser(
        'vm', help='virtual machines',
        description='Manage virtual machines.'
    )

    vm_subparsers = vm_parser.add_subparsers(dest='action', help='action')
    vm_subparsers.required = True

    vm_launch_subparser = vm_subparsers.add_parser(
        'launch', help='launch new virtual machine (VM) instances',
        description='Launch new virtual machine instances.'
    )
    vm_launch_subparser.set_defaults(function='vm_manage')

    vm_terminate_subparser = vm_subparsers.add_parser(
        'terminate', help='terminate existing virtual machine (VM) instances',
        description='Terminate existing virtual machine instances.'
    )
    vm_terminate_subparser.set_defaults(function='vm_manage')

    # TODO: start/stop subparsers once this functionality is implemented in
    # ansible modules os_server, ...

    vm_deploy_subparser = vm_subparsers.add_parser(
        'deploy',
        help='deploy TissueMAPS on existing virtual machine (VM) instances',
        description='Deploy TissueMAPS on existing virtual machine instances.'
    )
    vm_deploy_subparser.set_defaults(function='vm_manage')

    vm_show_subparser = vm_subparsers.add_parser(
        'show',
        help='show configured groups to hosts',
        description='Show configured groups and hosts defined in setup.yml file.'
    )
    vm_show_subparser.set_defaults(function='vm_show')

    container_parser = subparsers.add_parser(
        'container', help='docker containers',
        description='Manage Docker containers.'
    )

    container_subparsers = container_parser.add_subparsers(
        dest='action', help='action'
    )
    container_subparsers.required = True

    container_build_subparser = container_subparsers.add_parser(
        'build', help='build container images',
        description='Build container images.'
    )
    container_build_subparser.set_defaults(function='container_manage')

    container_run_subparser = container_subparsers.add_parser(
        'start', help='create and run containers',
        description='Create and run containers in the background.'
    )
    container_run_subparser.set_defaults(function='container_manage')

    container_stop_subparser = container_subparsers.add_parser(
        'stop', help='stop running containers',
        description='Stop running containers.'
    )
    container_stop_subparser.set_defaults(function='container_manage')

    container_push_subparser = container_subparsers.add_parser(
        'push', help='push container images to registry',
        description='Push built container images to Docker Hub registry.'
    )
    container_push_subparser.set_defaults(function='container_manage')

    args = parser.parse_args()

    configure_logging()
    log_level = map_logging_verbosity(args.verbosity)
    logger.setLevel(log_level)
    tmsetup_logger = logging.getLogger('tmsetup')
    tmsetup_logger.setLevel(log_level)

    main(args)
