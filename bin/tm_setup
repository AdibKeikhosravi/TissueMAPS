#!/usr/bin/env python
import os
import logging
import argparse
import subprocess
import sys
import collections
import elasticluster
from pkg_resources import resource_filename

import tmsetup
from tmsetup.config import Setup
from tmsetup.inventory import build_inventory_information
from tmsetup.log import configure_logging, map_logging_verbosity
from tmsetup.inventory import HOSTNAME_FORMAT
from tmsetup.errors import SetupDescriptionError
from tmsetup.utils import to_yaml, to_json


def _get_playbooks_dir(pkg_name):
    rel_path = os.path.join('share', 'playbooks')
    if not resource_exists(pkg_name, rel_path):
        raise OSError(
            'Package "%s" doesn\'t have resource: %s', pkg_name, rel_path
        )
    path = os.path.abspath(resource_filename(pkg_name, rel_path))
    if not os.path.exists(path):
        raise OSError('Playbooks path does not exist: %s', path)
    return path


def run(command):
    logger.debug('command: %s' % ' '.join(cmd))
    process = subprocess.Popen(command, stdout=subprocess.PIPE)
    for c in iter(lambda: process.stdout.read(1), ''):
        sys.stdout.write(c)


def get_deployment_groups(selected_cluster, selected_nodetype, selected_groups):
    logger.info('build Ansible commands')
    setup = Setup()
    groups_to_deploy = collections.defaultdict(list)
    for cluster in setup.grid.clusters:
        if selected_cluster is not None:
            if cluster.name != selected_cluster:
                continue
        for node_type in cluster.node_types:
            if selected_nodetype is not None:
                if node_type.name != selected_nodetype:
                    continue
            for group in node_type.groups:
                if selected_groups:
                    if group.name not in selected_groups:
                        continue
                logger.info('include Ansible group: %s', group.name)
                groups_to_deploy[group.name].append(group.playbook)

    required_groups = {
        'tissuemaps_web', 'tissuemaps_compute', 'tissuemaps_database'
    }
    for group in required_groups:
        if group not in groups_to_deploy.keys():
            logger.warn('core group "%s" not provided', group)

    return groups_to_deploy


def build_ansible_commands(action, verbosity, groups_to_deploy):
    commands = list()
    variables = dict()
    if action in {'launch', 'terminate', 'start', 'stop'}:
        if action == 'launch':
            logger.info('launch virtual machines')
            variables['instance_state'] = 'present'
        elif action == 'terminate':
            logger.info('terminate virtual machines')
            variables['instance_state'] = 'absent'
        elif action == 'start':
            # TODO: dependent on cloud provider
            # ec2: started
            # gce: running
            # os: -
            raise ValueError('Starting VMs is not yet supported')
        elif action == 'stop':
            # TODO: dependent on cloud provider
            # ec2: stopped
            # gce: stopped
            # os: -
            raise ValueError('Stopping VMs is not yet supported')
        cmd = _build_command(
            verbosity, os.path.join(PLAYBOOKS_HOME, 'instance.yml'), variables,
            set(groups_to_deploy)
        )
        commands.append(cmd)

    elif action == 'deploy':
        # This playbook must be called after the individual components have
        # been built.
        tmsetup_playbooks_dir = _get_playbooks_dir('tmsetup')
        playbook = os.path.join(PLAYBOOKS_HOME, 'site.yml')
        logger.debug('build command for playbook: %s', playbook)
        cmd = _build_command(
            verbosity, playbook, variables, set(groups_to_deploy.keys())
        )
        commands.append(cmd)

        elasticluster_playbooks_dir = _get_playbooks_dir('elasticluster')
        playbook = os.path.join(elasticluster_playbooks_dir, 'site.yml')
        logger.debug('build command for playbook: %s', playbook)
        variables['ansible_become'] = 'yes'
        logger.debug('run playbook in sudo mode')
        cmd = _build_command(
            verbosity, playbook, variables, set(groups_to_deploy.keys())
        )
        commands.append(cmd)

        for group, playbooks in groups_to_deploy.iteritems():
            for playbook in plays:
                if playbook is not None:
                    cmd = _build_command(
                        verbosity, playbook
                    )
                    commands.append(cmd)
            # # NOTE: variables are already provided via group_vars files
            # if group.vars is not None:
            #     for k, v in group.vars.iteritems():
            #         variables[k] = v

    return commands


def _build_command(verbosity, playbook, variables=dict(), hosts=set()):
    var_strings = list()
    for k, v in variables.iteritems():
        var_strings.append('='.join([k, v]))
    # The "tm_inventory" script should be on the path upon installation.
    cmd = ['ansible-playbook', '-i', 'tm_inventory', playbook]
    if verbosity > 0:
        cmd.append('-%s' % (verbosity * 'v'))
    if variables:
        cmd.extend(['-e', '%s' % ','.join(var_strings)])
    if hosts:
        cmd.extend(['--limit', '%s' % ','.join(hosts)])
    return cmd


def manage(args):
    groups = get_deployment_groups(args.cluster, args.node_type, args.groups)
    commands = build_ansible_commands(args.action, args.verbosity, groups)
    logger.info('run Ansible commands')
    for cmd in commands:
        run(cmd)


def show(args):
    groups = get_deployment_groups(args.cluster, args.node_type, args.groups)
    setup = Setup()
    inventory_info = build_inventory_information(setup)
    print to_yaml(inventory_info)


def main(args):
    context = globals()
    func = context.get(args.function)
    func(args)


if __name__ == '__main__':

    def check_dependency(required_arg, forbidden_args={}):
        class ArgumentDependencyAction(argparse.Action):
            def __call__(self, parser, namespace, values, option_string=None):
                if getattr(namespace, required_arg) is None:
                    parser.error(
                        'Argument "--%s" also requires "--%s".' % (
                            self.dest, required_arg
                        )
                    )
                if forbidden_args:
                    for arg in forbidden_args:
                        if getattr(namespace, arg) is not None:
                            parser.error(
                                'Argument "--%s" cannot be used together with '
                                ' "--%s".' % (self.dest, arg)
                            )
                setattr(namespace, self.dest, values)
        return ArgumentDependencyAction


    parser = argparse.ArgumentParser(
        description='Setup and deploy TissueMAPS in the cloud.'
    )
    parser.add_argument(
        '--verbosity', '-v', action='count', default=0,
        help='increase logging verbosity'
    )

    target_parser = argparse.ArgumentParser(add_help=False)
    target_parser.add_argument(
        '--cluster', '-c', metavar='CLUSTER', type=str,
        help='limit action to VMs of a particular cluster'
    )
    # NOTE: There is a bug in argparse that prevents using nargs='*' before
    # positional arguments (or subparser arguments)
    # http://bugs.python.org/issue9338
    target_parser.add_argument(
        '--groups', '-g', metavar='GROUP', type=str, nargs='*', default=[],
        help='limit action to VMs of individual Ansible group(s)'
    )
    target_parser.add_argument(
        '--node_type', '-n', metavar='NODETYPE', type=str,
        action=check_dependency('cluster'),
        help='limit action to VMs of a partiuclar cluster node_type'
    )

    subparsers = parser.add_subparsers(dest='action', help='action')
    subparsers.required = True

    launch_subparser = subparsers.add_parser(
        'launch', parents=[target_parser],
        help='launch new virtual machine (VM) instances'
    )
    launch_subparser.set_defaults(function='manage')
    launch_subparser.description = '''
        Launch new virtual machine instances.
    '''

    terminate_subparser = subparsers.add_parser(
        'terminate', parents=[target_parser],
        help='terminate existing virtual machine (VM) instances'
    )
    terminate_subparser.set_defaults(function='manage')
    terminate_subparser.description = '''
        Terminate existing virtual machine instances.
    '''

    # TODO: start/stop subparsers

    deploy_subparser = subparsers.add_parser(
        'deploy', parents=[target_parser],
        help='deploy TissueMAPS on existing virtual machine (VM) instances'
    )
    deploy_subparser.set_defaults(function='manage')
    deploy_subparser.description = '''
        Deploy TissueMAPS on existing virtual machine instances.
    '''

    show_subparser = subparsers.add_parser(
        'show', parents=[target_parser],
        help='show mapping of groups to hosts defined via setup config file'
    )
    show_subparser.set_defaults(function='show')
    show_subparser.description = '''
        Show mapping of groups to hosts defined via setup configuration file.
    '''

    args = parser.parse_args()
    args.groups = set(args.groups)

    configure_logging()
    log_level = map_logging_verbosity(args.verbosity)
    logger = logging.getLogger(os.path.basename(__file__))
    logger.setLevel(log_level)
    tmsetup_logger = logging.getLogger('tmsetup')
    tmsetup_logger.setLevel(log_level)

    main(args)
