#!/usr/bin/env python
import os
import logging
import argparse
import subprocess
import sys
import yaml
import collections
import elasticluster
from whichcraft import which
from pkg_resources import resource_filename, resource_exists

import tmsetup
from tmsetup.config import Setup
from tmsetup.inventory import build_inventory_information
from tmsetup.log import configure_logging, map_logging_verbosity
from tmsetup.inventory import HOSTNAME_FORMAT
from tmsetup.errors import SetupDescriptionError
from tmsetup.utils import to_yaml, to_json

logger = logging.getLogger(os.path.basename(__file__))

TM_GROUPS = {
    'tissuemaps_server', 'tissuemaps_compute',
    'tissuemaps_db_master', 'tissuemaps_db_worker'
}


def _get_playbooks_dir(pkg_name):
    rel_path = os.path.join('share', 'playbooks')
    if not resource_exists(pkg_name, rel_path):
        raise OSError(
            'Package "%s" doesn\'t have resource: %s', pkg_name, rel_path
        )
    path = os.path.abspath(resource_filename(pkg_name, rel_path))
    if not os.path.exists(path):
        raise OSError('Playbooks path does not exist: %s', path)
    return path


def get_deployment_groups(selected_cluster, selected_nodetype, selected_groups):
    logger.info('build Ansible commands')
    setup = Setup()
    groups_to_deploy = collections.defaultdict(list)
    for cluster in setup.architecture.clusters:
        if selected_cluster is not None:
            if cluster.name != selected_cluster:
                continue
        for node_type in cluster.node_types:
            if selected_nodetype is not None:
                if node_type.name != selected_nodetype:
                    continue
            for group in node_type.groups:
                if selected_groups:
                    if group.name not in selected_groups:
                        continue
                logger.info('include Ansible group: %s', group.name)
                groups_to_deploy[group.name].append(group.playbook)

    for group in TM_GROUPS:
        if group not in groups_to_deploy.keys():
            logger.warn('core group "%s" not provided', group)

    return groups_to_deploy


def _build_container_commands(action, verbosity):
    commands = list()
    playbooks_dir = _get_playbooks_dir('tmsetup')
    roles_dir = os.path.join(playbooks_dir, 'roles')
    vars_dir = os.path.join(playbooks_dir, 'group_vars')
    project_dir = os.path.join(playbooks_dir, '../container/projects/tissuemaps')
    cmd = _build_ansible_container_command(
        action, verbosity, project_dir, roles_dir, vars_dir
    )
    return [cmd]


def _build_ansible_container_command(mode, verbosity,
        project_dir, roles_dir, vars_dir):
    cmd = ['ansible-container', '--project', os.path.abspath(project_dir)]
    group_dirs = os.listdir(vars_dir)
    # NOTE: Ansible variables {{ }} declared in files are not expanded!
    for group in group_dirs:
        filename = os.path.abspath(os.path.join(vars_dir, group, 'vars.yml'))
        cmd.extend(['--var-file', filename])
    if verbosity > 3:
        cmd.append('--debug')
    cmd.extend([mode, '--roles-path', os.path.abspath(roles_dir)])
    if mode == 'build':
        cmd.append('--from-scratch')
        # The following options are parsed to the "ansible-playbooks" command.
        cmd.append('--')
        if verbosity > 1:
            verbosity -= 1
        if verbosity > 0:
            cmd.append('-%s' % (verbosity * 'v'))
        variables = collections.OrderedDict()
        for group in group_dirs:
            filename = os.path.abspath(os.path.join(vars_dir, group, 'vars.yml'))
            with open(filename) as f:
                for line in f.readlines():
                    var_mapping = yaml.load(line)
                    if var_mapping is None:
                        continue
                    for k, v in var_mapping.iteritems():
                        variables[k] = v
        for k, v in variables.iteritems():
            cmd.append('-e')
            var_string = '='.join([k, str(v)])
            # Values should not get quoted because this breaks
            # the docker-compose.yml Jinja templating approach of
            # ansible-container.
            cmd.append('%s' % var_string)
    elif mode == 'push':
        # NOTE: This works only with write access to the "tissuemaps"
        # organization on Docker Hub.
        cmd.extend(['--push-to', 'tissuemaps'])
    else:
        raise ValueError('Mode "%s" is not supported.' % action)
    return cmd


def _build_vm_commands(action, verbosity, groups_to_deploy):
    commands = list()
    variables = dict()
    if action in {'launch', 'terminate', 'start', 'stop'}:
        if action == 'launch':
            logger.info('launch virtual machines')
            variables['instance_state'] = 'present'
        elif action == 'terminate':
            logger.info('terminate virtual machines')
            variables['instance_state'] = 'absent'
        elif action == 'start':
            # TODO: functionality not yet supported by OpenStack modules
            # ec2: started
            # gce: running
            # os: -
            raise ValueError('Starting VMs is not yet supported')
        elif action == 'stop':
            # TODO: functionality not yet supported by OpenStack modules
            # ec2: stopped
            # gce: stopped
            # os: -
            raise ValueError('Stopping VMs is not yet supported')
        # First refresh inventory
        if args.refresh_cache:
            commands.append(['tm_inventory', '--refresh'])
        tmsetup_playbooks_dir = _get_playbooks_dir('tmsetup')
        playbook = os.path.join(tmsetup_playbooks_dir, 'instance.yml')
        cmd = _build_ansible_vm_command(
            verbosity, playbook, variables, set(groups_to_deploy)
        )
        commands.append(cmd)

    elif action == 'deploy':
        # This playbook must be called after the individual components have
        # been built.
        # First refresh inventory
        if args.refresh_cache:
            commands.append(['tm_inventory', '--refresh'])

        if set(groups_to_deploy.keys()) != TM_GROUPS:
            # Run the playbooks implemented in elasticluster. We only need
            # this in case we use groups not implemented in tmsetup.
            # NOTE: This playbook also configures SSH host-based authorization,
            # so it's a bad idea to run this only on a subset of groups!
            elasticluster_playbooks_dir = _get_playbooks_dir('elasticluster')
            playbook = os.path.join(elasticluster_playbooks_dir, 'site.yml')
            logger.debug('build command for playbook: %s', playbook)
            cmd = _build_ansible_vm_command(
                verbosity, playbook, variables, set(groups_to_deploy.keys())
            )
            cmd.extend(['-e', 'ansible_become=yes'])
            commands.append(cmd)

        # Run the TissueMAPS-specific playbooks implemented in tmsetup
        tmsetup_playbooks_dir = _get_playbooks_dir('tmsetup')
        playbook = os.path.join(tmsetup_playbooks_dir, 'site.yml')
        logger.debug('build command for playbook: %s', playbook)
        cmd = _build_ansible_vm_command(
            verbosity, playbook, variables, set(groups_to_deploy.keys())
        )
        cmd.extend(['-e', 'ansible_become=yes'])
        commands.append(cmd)

        for group, plays in groups_to_deploy.iteritems():
            for playbook in plays:
                if playbook is not None:
                    cmd = _build_ansible_vm_command(verbosity, playbook)
                    commands.append(cmd)

    return commands


def _build_ansible_vm_command(verbosity, playbook, variables=dict(), hosts=set()):
    var_strings = list()
    for k, v in variables.iteritems():
        var_strings.append('='.join([k, v]))
    # The "tm_inventory" script should be on the path upon installation.
    inventory_file = which('tm_inventory')
    cmd = ['ansible-playbook', '-i', inventory_file, playbook]
    if verbosity > 1:
        verbosity -= 1
    if verbosity > 0:
        cmd.append('-%s' % (verbosity * 'v'))
    # It's important that these strings get quoted for security reasons.
    if variables:
        cmd.extend(['-e', '%s' % ','.join(var_strings)])
    if hosts:
        cmd.extend(['--limit', '%s' % ','.join(hosts)])
    return cmd


def _run(command):
    logger.debug('command: %s' % ' '.join(command))
    process = subprocess.Popen(command, stdout=subprocess.PIPE)
    for c in iter(lambda: process.stdout.read(1), ''):
        sys.stdout.write(c)


def container_manage(args):
    commands = _build_container_commands(args.action, args.verbosity)
    logger.info('run Ansible commands')
    for cmd in commands:
        _run(cmd)


def vm_manage(args):
    groups = get_deployment_groups(args.cluster, args.node_type, args.groups)
    commands = _build_vm_commands(args.action, args.verbosity, groups)
    logger.info('run Ansible commands')
    for cmd in commands:
        _run(cmd)


def vm_show(args):
    groups = get_deployment_groups(args.cluster, args.node_type, args.groups)
    setup = Setup()
    inventory_info = build_inventory_information(setup)
    print to_yaml(inventory_info)


def main(args):
    context = globals()
    func = context.get(args.function)
    func(args)


if __name__ == '__main__':

    def check_dependency(required_arg, forbidden_args={}):
        class ArgumentDependencyAction(argparse.Action):
            def __call__(self, parser, namespace, values, option_string=None):
                if getattr(namespace, required_arg) is None:
                    parser.error(
                        'Argument "--%s" also requires "--%s".' % (
                            self.dest, required_arg
                        )
                    )
                if forbidden_args:
                    for arg in forbidden_args:
                        if getattr(namespace, arg) is not None:
                            parser.error(
                                'Argument "--%s" cannot be used together with '
                                ' "--%s".' % (self.dest, arg)
                            )
                setattr(namespace, self.dest, values)
        return ArgumentDependencyAction


    parser = argparse.ArgumentParser(
        description='Setup and deploy TissueMAPS in the cloud.'
    )
    parser.add_argument(
        '--verbosity', '-v', action='count', default=0,
        help='increase logging verbosity'
    )

    subparsers = parser.add_subparsers(dest='env', help='environment')
    subparsers.required = True

    vm_parser = subparsers.add_parser('vm', help='virtual machine')

    vm_target_parser = argparse.ArgumentParser(add_help=False)
    vm_target_parser.add_argument(
        '--cluster', '-c', metavar='CLUSTER', type=str,
        help='limit action to VMs of a particular cluster'
    )
    vm_target_parser.add_argument(
        '--groups', '-g', metavar='GROUP', type=str, nargs='*', default=[],
        help='limit action to VMs of individual Ansible group(s)'
    )
    vm_target_parser.add_argument(
        '--node_type', '-n', metavar='NODETYPE', type=str,
        action=check_dependency('cluster'),
        help='limit action to VMs of a partiuclar cluster node_type'
    )
    vm_target_parser.add_argument(
        '--no-refresh', dest='refresh_cache', action='store_false',
        help='when the inventory cache should not be refreshed'
    )

    vm_subparsers = vm_parser.add_subparsers(dest='action', help='action')
    vm_subparsers.required = True

    vm_launch_subparser = vm_subparsers.add_parser(
        'launch', parents=[vm_target_parser],
        help='launch new virtual machine (VM) instances'
    )
    vm_launch_subparser.set_defaults(function='vm_manage')
    vm_launch_subparser.description = '''
        Launch new virtual machine instances.
    '''

    vm_terminate_subparser = vm_subparsers.add_parser(
        'terminate', parents=[vm_target_parser],
        help='terminate existing virtual machine (VM) instances'
    )
    vm_terminate_subparser.set_defaults(function='vm_manage')
    vm_terminate_subparser.description = '''
        Terminate existing virtual machine instances.
    '''

    # TODO: start/stop subparsers once this functionality is implemented in
    # ansible modules os_server, ...

    vm_deploy_subparser = vm_subparsers.add_parser(
        'deploy', parents=[vm_target_parser],
        help='deploy TissueMAPS on existing virtual machine (VM) instances'
    )
    vm_deploy_subparser.set_defaults(function='vm_manage')
    vm_deploy_subparser.description = '''
        Deploy TissueMAPS on existing virtual machine instances.
    '''

    vm_show_subparser = vm_subparsers.add_parser(
        'show', parents=[vm_target_parser],
        help='show mapping of groups to hosts defined via setup config file'
    )
    vm_show_subparser.set_defaults(function='vm_show')
    vm_show_subparser.description = '''
        Show mapping of groups to hosts defined via setup configuration file.
    '''

    container_parser = subparsers.add_parser(
        'container', help='Docker container'
    )

    container_subparsers = container_parser.add_subparsers(
        dest='action', help='action'
    )
    container_subparsers.required = True

    container_build_subparser = container_subparsers.add_parser(
        'build', help='build container images'
    )
    container_build_subparser.set_defaults(function='container_manage')
    container_build_subparser.description = '''
        Build new container images.
    '''

    container_run_subparser = container_subparsers.add_parser(
        'run', help='run containers'
    )
    container_run_subparser.set_defaults(function='container_manage')
    container_run_subparser.description = '''
        Run containers. Requires a prior "build".
    '''

    container_stop_subparser = container_subparsers.add_parser(
        'stop', help='stop running containers'
    )
    container_stop_subparser.set_defaults(function='container_manage')
    container_stop_subparser.description = '''
        Stop running containers.
    '''

    container_push_subparser = container_subparsers.add_parser(
        'push', help='push container images to registry'
    )
    container_push_subparser.set_defaults(function='container_manage')
    container_push_subparser.description = '''
        Push container images to registry.
    '''

    args = parser.parse_args()
    if hasattr(args, 'groups'):
        args.groups = set(args.groups)

    configure_logging()
    log_level = map_logging_verbosity(args.verbosity)
    logger.setLevel(log_level)
    tmsetup_logger = logging.getLogger('tmsetup')
    tmsetup_logger.setLevel(log_level)

    main(args)
