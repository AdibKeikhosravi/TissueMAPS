#! /usr/bin/env python
# encoding: utf-8
import os
import os.path
import sys
import re
import segment
from tmt.illuminati import Mosaic
import tmt
from tmt.util import load_config, check_config
import tmt.image
from tmt.experiment import Experiment
from tmt.image import IntensityImage, MaskImage
from tmt.illuminati.illumcorrect import np_array_to_vips_image
from tmt.illuminati import logo, __version__

"""
Illuminati is a command line tool for pre-processing images for TissueMAPS.
It combines the following routines:
* shifting (-s)
* illumination correcting (-i)
* thresholding (-t)
Each of these routines comes with a separate command line interface that provides
additional functionality and can be used independently. For more details on the
individual steps see the respective files.

A potential call (from BASH) to this tool could look something like this:

    $ illuminati \\
        -sit TIFF/15*_r0[1-4]*_c0[1-4]*DAPI*.png -o out.png \\

See all available options with:

    $ illuminati --help

Some example use cases:

    - Create a pyramid out of segmentation files, retaining their 16 bit depth:

        $ illuminati --area-mask --png --make-global-ids path/to/*.png -o my_cell_id_pyramid

    - Create a pyramid of cell outlines, also retaining their 16 bit depth:

        $ illuminati --outline-mask --png path/to/*.png -o my_outline_pyramid

    - Create id tables:

        $ illuminati --id-luts path/to/label_matrices/*.png -o id_tables

"""


if __name__ == '__main__':
    import argparse

    print logo % {'version': __version__}

    parser = argparse.ArgumentParser(
        description='Create pyramid images for TissueMAPS.')

    parser.add_argument('files', nargs='*',
                        help='image files to process (globbing pattern),\
                        e.g. TIFF/*.png')

    parser.add_argument('-o', '--output', dest='output_dir', required=True,
                        help="directory where output should be saved")

    parser.add_argument('-c', '--config', dest='config',
                        help='path to custom yaml configuration file \
                        (defaults to "tmt" configuration)')

    parser.add_argument('-s', '--shift', dest='shift',
                        action='store_true', default=False,
                        help='shift stitched image according to descriptor file')

    parser.add_argument('-i', '--illum_correct', dest='illum_correct',
                        action='store_true', default=False,
                        help='correct images for illumination\
                        according to stats file')

    parser.add_argument('-t', '--thresh', dest='thresh',
                        action='store_true', default=False,
                        help='threshold (rescale) stitched image')
    parser.add_argument('--thresh-value', dest='thresh_value',
                        type=float, default=False,
                        help='pixel value for threshold')
    parser.add_argument('--thresh-percent', dest='thresh_percent',
                        type=float, default=0.01,
                        help='percentage of pixel values above threshold')
    parser.add_argument('--thresh-sample', dest='thresh_sample',
                        type=int, default=10,
                        help='number of files to use for threshold estimation')

    parser.add_argument('--id-luts', dest='id_luts',
                        action='store_true', default=False,
                        help='if lookup tables for the cell ids should be '
                        'created. These tables are just int32 numpy arrays '
                        'with the same name as the original segmentations.')

    parser.add_argument('--area-mask', dest='area_mask',
                        action='store_true', default=False,
                        help='create masks that consist of whole objects')
    parser.add_argument('-m', '--outline-mask', dest='outline_mask',
                        action='store_true', default=False,
                        help='create masks that consist of object outlines')

    parser.add_argument('--make-global-ids', dest='make_global_ids',
                        action='store_true', default=False,
                        help='if all the cell labels should be made into '
                             'globally unique labels.')
    parser.add_argument('--png', dest='png',
                        action='store_true', default=False,
                        help='Save the pyramid tiles as png, default is jpg.')
    parser.add_argument('--no-rescale', dest='no_rescale',
                        action='store_true', default=False,
                        help='don\'t perform any 16bit -> 8bit rescaling. '
                        'The resulting pyramid will have 16bit PNG tiles.')

    args = parser.parse_args()

    output_dir = args.output_dir
    files = args.files

    #######################################################################
    #                       PREPARATORY FILE HANDLING                     #
    #######################################################################

    if not args.files or not all(map(tmt.image.is_image_file, args.files)):
        parser.print_help()
        sys.exit(1)

    if not output_dir:
        print 'You need to specify an output directory'
        sys.exit(1)

    if args.outline_mask or args.area_mask:
        # TissueMAPS requires mask layer folders to end on "_Mask"
        if not re.search('_Mask$', output_dir):
            output_dir = '%s_Mask' % output_dir

    if not os.path.exists(output_dir) and not args.id_luts:
        print '.. Creating output directory: "%s"' % output_dir
        os.makedirs(output_dir)

    if args.config:
        # Overwrite default "tmt" configuration
        config = load_config(args.config)
        check_config(config)
    else:
        config = tmt.config

    if args.area_mask or args.outline_mask:
        images = [MaskImage(f, config, vips=True) for f in files]
    elif args.id_luts:
        images = [MaskImage(f, config) for f in files]
    else:
        images = [IntensityImage(f, config, vips=True) for f in files]
    experiment_dir = images[0].experiment_dir
    experiment = Experiment(experiment_dir, config)
    cycles = experiment.subexperiments
    current_cycle = images[0].cycle
    data_filename = experiment.data_filename

    if args.thresh_sample > len(images):
        args.thresh_sample = len(images)

    #######################################################################
    #                           LOADING IMAGES                            #
    #######################################################################

    layer = Mosaic(images)

    if args.id_luts:
        print('ᐄ  CREATING ID LOOKUP TABLES ')
        segment.create_and_save_lookup_tables(layer.image_grid, data_filename,
                                              output_dir)
        sys.exit(0)

    # Create a vips image for each file
    print '.. Loading images'
    if args.outline_mask or args.area_mask:
        if args.outline_mask:
            print('ᐄ  CREATING OUTLINE MASKS')
            layer.build_mask_grid(data_filename, mask='outline',
                                  make_global_ids=args.make_global_ids)
        elif args.area_mask:
            print('ᐄ  CREATING AREA MASKS')
            layer.build_mask_grid(data_filename, mask='area',
                                  make_global_ids=args.make_global_ids)
    else:
        layer.build_channel_grid()

    #######################################################################
    #                       ILLUMINATION CORRECTING                       #
    #######################################################################

    if args.illum_correct:
        print 'ᐄ  CORRECTING IMAGES FOR ILLUMINATION'

        # retrieve illumination correction statistics
        project = [c.project for c in cycles if c.cycle == images[0].cycle][0]
        channel_index = [i for i, s in enumerate(project.stats_files)
                         if s.channel == images[0].channel][0]
        mean, std = project.stats_files[channel_index].statistics
        mean = np_array_to_vips_image(mean)
        std = np_array_to_vips_image(std)

        layer.apply_illumination_correction_to_grid(mean, std)

    #######################################################################
    #                             STITCHING                               #
    #######################################################################

    print '.. Stitching images to mosaic image'

    layer.stitch_images()

    #######################################################################
    #                              SHIFTING                               #
    #######################################################################

    if args.shift:
        print 'ᐄ  SHIFTING MOSAIC IMAGE'
        layer.shift_stitched_image(cycles, current_cycle)

    #######################################################################
    #                            THRESHOLDING                             #
    #######################################################################

    if args.thresh:
        print 'ᐄ  THRESHOLDING MOSAIC IMAGE'
        if args.thresh_value:
            print '   ... Using provided threshold value'
        else:
            print('   ... Computing threshold value corresponding to the %d\% '
                  'highest pixel values on %d sampled images'
                  % (args.thresh_percent, args.thresh_sample))

        layer.apply_threshold_to_stitched_image(
                    thresh_value=args.thresh_value,
                    thresh_sample=args.thresh_sample,
                    thresh_percent=args.thresh_percent
        )

    if not args.make_global_ids and not args.no_rescale:
        print '.. Rescaling mosaic image'
        layer.scale_stitched_image()

    #######################################################################
    #                            PYRAMIDIZING                             #
    #######################################################################

    print '.. Creating pyramid from mosaic image'
    if not args.no_rescale and not args.png:
        layer.create_pyramid(output_dir)
    else:
        # The stitched image wasn't rescaled and is still 16 bit.
        # In order to have the resulting pyramid be 16 bit as well, we have
        # do change the file format from JPEG to PNG.
        # Note that pyramids created in this manner shouldn't be visualized
        # directly in the browser since they will be coerced to 8 bit,
        # which will result in loss of information.
        layer.create_pyramid(output_dir, tile_file_extension='.png')

    print '🍺  Done!'
